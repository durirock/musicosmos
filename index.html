<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Musicosmos - Universo Musical Interactivo</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background-color: #000;
            color: white;
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            background-color: rgba(0,0,0,0.5);
            padding: 10px;
            z-index: 100;
            opacity: 1;
            transition: opacity 2s ease-in;
        }
        .fade-out {
            opacity: 0 !important; /* Añadimos !important para forzar la prioridad */
            transition: opacity 2s ease-in; /* Reducir a 2 segundos para una transición más rápida */
            pointer-events: none; /* Impedir que se pueda hacer click después del fade */
        }
        #midiStatus {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            background-color: rgba(0,0,0,0.5);
            padding: 10px;
            z-index: 100;
            border-radius: 5px;
        }
        #coordinates {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background-color: rgba(0,0,0,0.7);
            padding: 10px;
            z-index: 100;
            border-radius: 5px;
            font-family: monospace;
            font-size: 14px;
        }
        #teleportPanel {
            position: absolute;
            bottom: 60px;
            left: 10px;
            color: white;
            background-color: rgba(0,0,0,0.7);
            padding: 15px;
            z-index: 100;
            border-radius: 5px;
            display: none;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(100, 120, 255, 0.3);
            box-shadow: 0 0 15px rgba(100, 120, 255, 0.3);
        }
        #teleportPanel input {
            width: 60px;
            background-color: rgba(30,30,40,0.8);
            color: white;
            border: 1px solid #557;
            border-radius: 3px;
            padding: 5px;
            margin: 0 5px;
            font-family: monospace;
        }
        #teleportPanel button {
            background-color: #4466dd;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 6px 12px;
            cursor: pointer;
            margin-left: 10px;
        }
        #teleportPanel button:hover {
            background-color: #5577ee;
        }
        canvas {
            display: block;
        }
        .btn-settings {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            background-color: rgba(50,50,70,0.6);
            color: white;
            border: none;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            box-shadow: 0 0 15px rgba(100,100,255,0.5);
            z-index: 200;
        }
        .btn-settings:hover {
            background-color: rgba(70,70,100,0.8);
            transform: scale(1.1);
        }
        .btn-teleport {
            position: absolute;
            bottom: 20px;
            left: 10px;
            background-color: rgba(50,50,70,0.6);
            color: white;
            border: none;
            border-radius: 5px;
            padding: 10px 15px;
            font-size: 14px;
            cursor: pointer;
            transition: background-color 0.3s;
            box-shadow: 0 0 10px rgba(100,100,255,0.5);
            z-index: 200;
        }
        .btn-teleport:hover {
            background-color: rgba(70,70,100,0.8);
        }
        .btn-perspective {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background-color: rgba(50,50,70,0.6);
            color: white;
            border: none;
            border-radius: 5px;
            padding: 10px 15px;
            font-size: 14px;
            cursor: pointer;
            transition: background-color 0.3s;
            box-shadow: 0 0 10px rgba(100,100,255,0.5);
            z-index: 200;
        }
        .btn-perspective:hover {
            background-color: rgba(70,70,100,0.8);
        }
        #settingsMenu {
            position: absolute;
            top: 80px;
            right: 20px;
            width: 300px;
            max-height: 80vh;
            overflow-y: auto;
            background-color: rgba(30,30,50,0.9);
            color: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 0 20px rgba(0,0,255,0.3);
            z-index: 200;
            display: none;
            backdrop-filter: blur(5px);
        }
        #settingsMenu h3 {
            margin-top: 0;
            color: #aaf;
            border-bottom: 1px solid #557;
            padding-bottom: 10px;
        }
        #viewControls {
            position: absolute;
            right: 20px;
            bottom: 70px;
            color: white;
            background-color: rgba(0,0,0,0.5);
            padding: 10px;
            z-index: 100;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        #viewControls button {
            background-color: rgba(50,50,70,0.6);
            color: white;
            border: none;
            border-radius: 5px;
            padding: 5px 10px;
            font-size: 12px;
            cursor: pointer;
        }
        #viewControls button:hover {
            background-color: rgba(70,70,100,0.8);
        }
        .midi-device-item {
            margin-bottom: 10px;
            padding: 8px;
            background-color: rgba(50,50,80,0.5);
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .midi-device-item.active {
            background-color: rgba(80,80,180,0.5);
            border-left: 3px solid #88f;
        }
        .toggle-button {
            width: 40px;
            height: 20px;
            background-color: #444;
            border-radius: 10px;
            position: relative;
            cursor: pointer;
        }
        .toggle-button.active {
            background-color: #55f;
        }
        .toggle-button::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            background-color: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: transform 0.3s;
        }
        .toggle-button.active::after {
            transform: translateX(20px);
        }
        .network-status {
            margin-top: 20px;
            padding-top: 10px;
            border-top: 1px solid #557;
        }
        #usernameInput {
            width: 100%;
            padding: 8px;
            margin: 10px 0;
            background-color: rgba(40,40,60,0.9);
            color: white;
            border: 1px solid #557;
            border-radius: 5px;
        }
        #connectButton {
            padding: 8px 16px;
            background-color: #4466dd;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        #connectButton:hover {
            background-color: #5577ee;
        }
    </style>
</head>
<body>
    <div id="info">
        <h1>Musicosmos</h1>
        <p>Conecta un dispositivo MIDI y toca para crear galaxias musicales.</p>
        <p>Usa las teclas W, A, S, D para moverte, ratón para navegar en todas direcciones.</p>
    </div>
    
    <div id="midiStatus">Esperando conexión MIDI...</div>
    <div id="coordinates">X: 0.00, Y: 0.00, Z: 0.00</div>
    
    <button class="btn-teleport" id="btnTeleport">Teletransporte</button>
    <button class="btn-perspective" id="btnPerspective">Cambiar Vista</button>
    
    <div id="teleportPanel">
        <div>X: <input type="number" id="teleportX" step="0.1"></div>
        <div>Y: <input type="number" id="teleportY" step="0.1"></div>
        <div>Z: <input type="number" id="teleportZ" step="0.1"></div>
        <button id="btnGoToCoords">Ir a Coordenadas</button>
    </div>
    
    <div id="viewControls">
        <button id="btnFirstPerson">Vista en Primera Persona</button>
        <button id="btnThirdPerson">Vista en Tercera Persona</button>
        <button id="btnBirdEye">Vista de Pájaro</button>
    </div>
    
    <button class="btn-settings" id="btnSettings">⚙️</button>
    
    <div id="settingsMenu">
        <h3>Configuración</h3>
        <div>
            <h4>Dispositivos MIDI</h4>
            <div id="midiDevicesContainer">
                <p>No se encontraron dispositivos MIDI</p>
            </div>
        </div>
        
        <div class="network-status">
            <h4>Multijugador</h4>
            <input type="text" id="usernameInput" placeholder="Tu nombre en el cosmos" maxlength="20">
            <button id="connectButton">Conectar</button>
            <div id="playersOnline"></div>
        </div>
        <div class="galaxy-settings">
            <h4>Configuración de Galaxia</h4>
            <div class="setting-item">
              <label for="galaxySize">Tamaño de Galaxia:</label>
              <input type="range" id="galaxySize" min="15" max="50" value="25" class="slider">
              <span id="galaxySizeValue">25</span>
            </div>
            <div class="setting-item">
              <label for="particleCount">Partículas Afectadas por Nota:</label>
              <input type="range" id="particleCount" min="5" max="30" value="12" class="slider">
              <span id="particleCountValue">12%</span>
            </div>
            <div class="setting-item">
              <label for="colorMixing">Intensidad de Mezcla de Color:</label>
              <input type="range" id="colorMixing" min="30" max="80" value="50" class="slider">
              <span id="colorMixingValue">50%</span>
            </div>
            <div class="setting-item">
              <label for="expansionTime">Tiempo de Expansión:</label>
              <input type="range" id="expansionTime" min="2000" max="8000" value="4000" step="1000" class="slider">
              <span id="expansionTimeValue">4s</span>
            </div>
            <div class="setting-item">
              <label for="fadeoutTime">Tiempo de Inactividad:</label>
              <input type="range" id="fadeoutTime" min="10000" max="60000" value="20000" step="5000" class="slider">
              <span id="fadeoutTimeValue">20s</span>
            </div>
            <button id="applyGalaxySettings" class="settings-button">Aplicar Configuración</button>
            <button id="resetGalaxySettings" class="settings-button secondary">Restaurar Valores</button>
          </div>
          
          <!-- Estilos para el panel de configuración -->
          <style>
            .galaxy-settings {
              margin-top: 20px;
              padding-top: 15px;
              border-top: 1px solid #557;
            }
            
            .setting-item {
              margin: 12px 0;
              display: flex;
              align-items: center;
              flex-wrap: wrap;
            }
            
            .setting-item label {
              width: 100%;
              margin-bottom: 5px;
              color: #aaf;
              font-size: 14px;
            }
            
            .slider {
              flex: 1;
              height: 6px;
              appearance: none;
              background: rgba(50,50,100,0.6);
              border-radius: 3px;
              margin-right: 10px;
            }
            
            .slider::-webkit-slider-thumb {
              appearance: none;
              width: 15px;
              height: 15px;
              border-radius: 50%;
              background: #4466dd;
              cursor: pointer;
            }
            
            .slider::-moz-range-thumb {
              width: 15px;
              height: 15px;
              border-radius: 50%;
              background: #4466dd;
              cursor: pointer;
            }
            
            .settings-button {
              padding: 8px 16px;
              background-color: #4466dd;
              color: white;
              border: none;
              border-radius: 5px;
              cursor: pointer;
              margin-top: 10px;
              margin-right: 10px;
            }
            
            .settings-button:hover {
              background-color: #5577ee;
            }
            
            .settings-button.secondary {
              background-color: #555;
            }
            
            .settings-button.secondary:hover {
              background-color: #777;
            }
          </style>
          
          <!-- Script para manejar la configuración de la galaxia -->
          <script>
          // Variables para almacenar la configuración de la galaxia
          let galaxySettings = {
            size: 25,
            particleCount: 12,
            colorMixing: 50,
            expansionTime: 4000,
            fadeoutTime: 20000
          };
          
          // Función para inicializar los sliders y eventos
          function initGalaxySettings() {
            // Vincular sliders con sus valores de visualización
            const sliders = {
                'galaxySize': { elem: document.getElementById('galaxySizeValue'), suffix: '', key: 'size' },
                'particleCount': { elem: document.getElementById('particleCountValue'), suffix: '%', key: 'particleCount' },
                'colorMixing': { elem: document.getElementById('colorMixingValue'), suffix: '%', key: 'colorMixing' },
                'expansionTime': { elem: document.getElementById('expansionTimeValue'), suffix: 's', key: 'expansionTime' },
                'fadeoutTime': { elem: document.getElementById('fadeoutTimeValue'), suffix: 's', key: 'fadeoutTime' }
            };
            
            // Configurar eventos de los sliders
            Object.keys(sliders).forEach(sliderId => {
                const slider = document.getElementById(sliderId);
                const info = sliders[sliderId];
                
                slider.addEventListener('input', () => {
                let displayValue = slider.value;
                
                // Formatear valores especiales
                if (sliderId === 'expansionTime' || sliderId === 'fadeoutTime') {
                    displayValue = (slider.value / 1000).toFixed(0);
                }
                
                info.elem.textContent = displayValue + info.suffix;
                galaxySettings[info.key] = parseInt(slider.value);
                
                // Aplicar cambios inmediatamente
                applyGalaxySettings(false); // Pasar false para no mostrar notificación
                });
            });
            
            // El botón aplicar ahora solo guarda la configuración
            document.getElementById('applyGalaxySettings').textContent = 'Guardar Configuración';
            document.getElementById('applyGalaxySettings').addEventListener('click', saveGalaxySettings);
            
            // Botón restaurar valores
            document.getElementById('resetGalaxySettings').addEventListener('click', resetGalaxySettings);
            }

            // Modificar la función applyGalaxySettings para aceptar un parámetro de notificación
            function applyGalaxySettings(showNotification = true) {
            // Solo guardar en localStorage si se solicita explícitamente (botón)
            if (showNotification) {
                localStorage.setItem('musicosmosGalaxySettings', JSON.stringify(galaxySettings));
            }
            
            // Aplicar a configuración global que se usará para nuevas galaxias
            if (GALAXY_PIXEL_CONFIG) {
                GALAXY_PIXEL_CONFIG.maxExpansion = galaxySettings.size;
            }
            
            // Aplicar a galaxias existentes
            for (const galaxyId in galaxies) {
                const galaxy = galaxies[galaxyId];
                if (galaxy && galaxy.pixelGalaxy && galaxy.pixelGalaxy.config) {
                // Actualizar configuración
                galaxy.pixelGalaxy.config.maxExpansion = galaxySettings.size;
                galaxy.pixelGalaxy.config.particleAffectedRatio = galaxySettings.particleCount / 100;
                galaxy.pixelGalaxy.config.colorMixFactor = galaxySettings.colorMixing / 100;
                galaxy.pixelGalaxy.config.expansionTime = galaxySettings.expansionTime;
                galaxy.pixelGalaxy.config.inactivityTime = galaxySettings.fadeoutTime;
                }
            }
            
            // Notificar solo si se solicita (al usar el botón guardar)
            if (showNotification) {
                showNotification('Configuración guardada', 2000);
            }
            }

            // Nueva función para guardar la configuración
            function saveGalaxySettings() {
            localStorage.setItem('musicosmosGalaxySettings', JSON.stringify(galaxySettings));
            showNotification('Configuración guardada', 2000);
            }
          
          // Función para restaurar valores predeterminados
          function resetGalaxySettings() {
            // Restaurar valores por defecto
            document.getElementById('galaxySize').value = 25;
            document.getElementById('galaxySizeValue').textContent = '25';
            document.getElementById('particleCount').value = 12;
            document.getElementById('particleCountValue').textContent = '12%';
            document.getElementById('colorMixing').value = 50;
            document.getElementById('colorMixingValue').textContent = '50%';
            document.getElementById('expansionTime').value = 4000;
            document.getElementById('expansionTimeValue').textContent = '4s';
            document.getElementById('fadeoutTime').value = 20000;
            document.getElementById('fadeoutTimeValue').textContent = '20s';
            
            // Actualizar objeto de configuración
            galaxySettings = {
              size: 25,
              particleCount: 12,
              colorMixing: 50,
              expansionTime: 4000,
              fadeoutTime: 20000
            };
            
            // Aplicar valores restaurados
            applyGalaxySettings();
          }
          
          // Función auxiliar para mostrar notificaciones
          function showNotification(message, duration = 3000) {
            // Crear elemento de notificación si no existe
            let notification = document.getElementById('notification');
            if (!notification) {
              notification = document.createElement('div');
              notification.id = 'notification';
              notification.style.position = 'fixed';
              notification.style.bottom = '20px';
              notification.style.left = '50%';
              notification.style.transform = 'translateX(-50%)';
              notification.style.backgroundColor = 'rgba(68, 102, 221, 0.8)';
              notification.style.color = 'white';
              notification.style.padding = '10px 20px';
              notification.style.borderRadius = '5px';
              notification.style.zIndex = '1000';
              notification.style.transition = 'opacity 0.3s';
              document.body.appendChild(notification);
            }
            
            // Mostrar mensaje
            notification.textContent = message;
            notification.style.opacity = '1';
            
            // Ocultar después de la duración
            setTimeout(() => {
              notification.style.opacity = '0';
            }, duration);
          }
          
          // Cargar configuración guardada al iniciar
          function loadGalaxySettings() {
            const savedSettings = localStorage.getItem('musicosmosGalaxySettings');
            if (savedSettings) {
              try {
                const parsedSettings = JSON.parse(savedSettings);
                galaxySettings = parsedSettings;
                
                // Actualizar sliders con valores guardados
                document.getElementById('galaxySize').value = galaxySettings.size;
                document.getElementById('galaxySizeValue').textContent = galaxySettings.size;
                document.getElementById('particleCount').value = galaxySettings.particleCount;
                document.getElementById('particleCountValue').textContent = galaxySettings.particleCount + '%';
                document.getElementById('colorMixing').value = galaxySettings.colorMixing;
                document.getElementById('colorMixingValue').textContent = galaxySettings.colorMixing + '%';
                document.getElementById('expansionTime').value = galaxySettings.expansionTime;
                document.getElementById('expansionTimeValue').textContent = (galaxySettings.expansionTime / 1000) + 's';
                document.getElementById('fadeoutTime').value = galaxySettings.fadeoutTime;
                document.getElementById('fadeoutTimeValue').textContent = (galaxySettings.fadeoutTime / 1000) + 's';
              } catch (e) {
                console.error('Error al cargar configuración guardada:', e);
              }
            }
          }
          
          // Inicializar configuración cuando el DOM esté cargado
          document.addEventListener('DOMContentLoaded', function() {
            // Inicializar cuando el DOM esté listo
            initGalaxySettings();
            
            // Cargar configuración guardada
            loadGalaxySettings();
          });
          </script>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Variables principales
        let scene, camera, renderer;
        let galaxies = {};
        let particles = [];  // Para mezcla de colores global
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let moveUp = false;
        let moveDown = false;
        let rotateCameraLeft = false;
        let rotateCameraRight = false;
        const cameraRotationSpeed = 0.02; // Velocidad de rotación
        let pitchAngle = 0;
        let yawAngle = 0;
        let gridHelper;
        let proceduralGenerator; // Añade esta línea
        let hyperspaceEffect;
        let hyperspaceModeActive = false;

        // Añade esto después de las variables principales (let scene, camera, renderer; etc.)

        // Sistema de generación procedural para Musicosmos
        // Versión mejorada del sistema procedural
        class ProceduralGenerator {
            constructor(scene, chunkSize = 200) {
                this.scene = scene;
                this.chunkSize = chunkSize;
                this.activeChunks = new Map();
                this.visibleDistance = 2;
                this.playerPosition = new THREE.Vector3();
                this.currentChunkCoords = null;
                this.chunkSeed = 12345;
                this.nebulaeObjects = []; // Tracking para animación de nebulosas
            }

            update(playerPosition) {
                this.playerPosition.copy(playerPosition);
                
                const chunkX = Math.floor(playerPosition.x / this.chunkSize);
                const chunkY = Math.floor(playerPosition.y / this.chunkSize);
                const chunkZ = Math.floor(playerPosition.z / this.chunkSize);
                const chunkCoords = `${chunkX},${chunkY},${chunkZ}`;
                
                if (this.currentChunkCoords !== chunkCoords) {
                    this.currentChunkCoords = chunkCoords;
                    this.updateChunks();
                }
                
                // Animar las nebulosas
                this.animateNebulae();
            }
            
            updateChunks() {
                const [chunkX, chunkY, chunkZ] = this.currentChunkCoords.split(',').map(Number);
                const chunksToKeep = new Set();
                
                for (let x = chunkX - this.visibleDistance; x <= chunkX + this.visibleDistance; x++) {
                    for (let y = chunkY - this.visibleDistance; y <= chunkY + this.visibleDistance; y++) {
                        for (let z = chunkZ - this.visibleDistance; z <= chunkZ + this.visibleDistance; z++) {
                            const coords = `${x},${y},${z}`;
                            chunksToKeep.add(coords);
                            
                            if (!this.activeChunks.has(coords)) {
                                this.generateChunk(x, y, z);
                            }
                        }
                    }
                }
                
                for (const coords of this.activeChunks.keys()) {
                    if (!chunksToKeep.has(coords)) {
                        this.removeChunk(coords);
                    }
                }
            }
            
            generateChunk(x, y, z) {
                console.log(`Generando cuadrante en [${x}, ${y}, ${z}]`);
                const chunkId = `${x},${y},${z}`;
                
                const chunkObject = new THREE.Group();
                chunkObject.position.set(
                    x * this.chunkSize + this.chunkSize/2,
                    y * this.chunkSize + this.chunkSize/2,
                    z * this.chunkSize + this.chunkSize/2
                );
                
                const chunkSeed = this.getChunkSeed(x, y, z);
                
                // Generar estrellas para este cuadrante
                this.generateStars(chunkObject, chunkSeed);
                
                // Reducir la probabilidad de nebulosas al 10%
                if (this.pseudoRandom(chunkSeed + 123) < 0.10) {
                    this.generateNebula(chunkObject, chunkSeed);
                }
                
                // Aplicar aparición gradual
                this.applyFadeInEffect(chunkObject);
                
                this.scene.add(chunkObject);
                this.activeChunks.set(chunkId, chunkObject);
            }

            
            // Aplicar efecto de aparición gradual
            applyFadeInEffect(chunkObject) {
                // Comenzar con opacidad cero
                chunkObject.traverse(object => {
                    if (object.material) {
                        if (Array.isArray(object.material)) {
                            object.material.forEach(mat => {
                                mat.transparent = true;
                                mat._originalOpacity = mat.opacity || 1.0;
                                mat.opacity = 0;
                            });
                        } else {
                            object.material.transparent = true;
                            object.material._originalOpacity = object.material.opacity || 1.0;
                            object.material.opacity = 0;
                        }
                    }
                });
                
                // Definir la duración de la aparición gradual
                const fadeInDuration = 1000; // 1.5 segundos
                const startTime = Date.now();
                
                const fadeIn = () => {
                    const elapsedTime = Date.now() - startTime;
                    const progress = Math.min(1, elapsedTime / fadeInDuration);
                    
                    // Aplicar opacidad gradual
                    chunkObject.traverse(object => {
                        if (object.material) {
                            if (Array.isArray(object.material)) {
                                object.material.forEach(mat => {
                                    if (mat._originalOpacity) {
                                        mat.opacity = progress * mat._originalOpacity;
                                    }
                                });
                            } else if (object.material._originalOpacity) {
                                object.material.opacity = progress * object.material._originalOpacity;
                            }
                        }
                    });
                    
                    if (progress < 1) {
                        requestAnimationFrame(fadeIn);
                    }
                };
                
                // Iniciar la animación de aparición
                fadeIn();
            }
            
            removeChunk(chunkId) {
                const chunkObject = this.activeChunks.get(chunkId);
                if (chunkObject) {
                    // Eliminar las nebulosas asociadas de la lista de animación
                    this.nebulaeObjects = this.nebulaeObjects.filter(nebData => {
                        return !chunkObject.children.includes(nebData.object);
                    });
                    
                    // Eliminar todos los objetos del cuadrante
                    this.disposeChunkContents(chunkObject);
                    this.scene.remove(chunkObject);
                    this.activeChunks.delete(chunkId);
                    console.log(`Eliminando cuadrante ${chunkId}`);
                }
            }
            
            disposeChunkContents(chunkObject) {
                chunkObject.traverse(object => {
                    if (object.geometry) {
                        object.geometry.dispose();
                    }
                    
                    if (object.material) {
                        if (Array.isArray(object.material)) {
                            object.material.forEach(material => material.dispose());
                        } else {
                            object.material.dispose();
                        }
                    }
                });
            }
            
            pseudoRandom(seed) {
                const x = Math.sin(seed) * 10000;
                return x - Math.floor(x);
            }
            
            getChunkSeed(x, y, z) {
                return this.chunkSeed + x * 73856093 + y * 19349663 + z * 83492791;
            }
            
            // Genera estrellas dentro del cuadrante (versión actualizada)
            generateStars(chunkObject, seed) {
                // Reducir cantidad de estrellas
                const starCount = Math.floor(this.pseudoRandom(seed) * 150) + 30; // Reducido de 500+100 a 150+50
                
                const starGeometry = new THREE.BufferGeometry();
                const starPositions = new Float32Array(starCount * 3);
                const starColors = new Float32Array(starCount * 3);
                const starSizes = new Float32Array(starCount);
                
                for (let i = 0; i < starCount; i++) {
                    const offsetX = (this.pseudoRandom(seed + i) - 0.5) * this.chunkSize;
                    const offsetY = (this.pseudoRandom(seed + i + 1000) - 0.5) * this.chunkSize;
                    const offsetZ = (this.pseudoRandom(seed + i + 2000) - 0.5) * this.chunkSize;
                    
                    starPositions[i * 3] = offsetX;
                    starPositions[i * 3 + 1] = offsetY;
                    starPositions[i * 3 + 2] = offsetZ;
                    
                    // Color y tamaño basado en posición
                    const colorOffset = this.pseudoRandom(seed + i * 3) * 0.2;
                    starColors[i * 3] = 0.8 + colorOffset;
                    starColors[i * 3 + 1] = 0.8 + colorOffset;
                    starColors[i * 3 + 2] = 0.9 + colorOffset * 0.5;
                    
                    // Tamaño reducido
                    starSizes[i] = 0.2 + this.pseudoRandom(seed + i * 7) * 0.5; // Reducido de 0.5+1.5 a 0.3+0.7
                }
                
                starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
                starGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
                starGeometry.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));
                
                const starMaterial = new THREE.PointsMaterial({
                    size: 0.2, // Reducido de 1.0 a 0.7
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.8,
                    sizeAttenuation: true
                });
                
                const stars = new THREE.Points(starGeometry, starMaterial);
                chunkObject.add(stars);
            }
            
            // Genera una nebulosa dentro del cuadrante (versión actualizada con movimiento)
           // Versión mejorada con tamaños de nebulosas variables

            // Modificar el método de generación de nebulosas
            generateNebula(chunkObject, seed) {
                // Determinar el tamaño de la nebulosa - pequeña, mediana o grande
                const sizeCategory = this.pseudoRandom(seed + 222);
                let nebulaSizeBase, particleCount;
                
                if (sizeCategory < 0.33) {
                    // Nebulosa pequeña (33% de probabilidad)
                    nebulaSizeBase = 30;
                    particleCount = 1500; // Menos partículas para nebulosas pequeñas
                } else if (sizeCategory < 0.85) {
                    // Nebulosa mediana (52% de probabilidad)
                    nebulaSizeBase = 70;
                    particleCount = 3000; // Partículas estándar para nebulosas medianas
                } else {
                    // Nebulosa grande (15% de probabilidad)
                    nebulaSizeBase = 120;
                    particleCount = 5000; // Más partículas para nebulosas grandes
                }
                
                // Añadir variación al tamaño base
                const nebulaSize = nebulaSizeBase + this.pseudoRandom(seed + 333) * (nebulaSizeBase * 0.4);
                
                // Usar colores variados como en el procedural actual
                const hue = this.pseudoRandom(seed + 444); // Color aleatorio (0-1)
                const saturation = 0.6 + this.pseudoRandom(seed + 555) * 0.4; // Entre 0.6 y 1.0
                const baseLightness = 0.4 + this.pseudoRandom(seed + 666) * 0.2; // Entre 0.4 y 0.6
                
                // Crear geometría para la nebulosa
                const nebulaGeometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                const sizes = new Float32Array(particleCount);
                
                // Distribución de partículas mejorada para núcleo más definido
                for (let i = 0; i < particleCount; i++) {
                    // Determinar si esta partícula será parte del núcleo o de la región externa
                    const isCore = this.pseudoRandom(seed + i * 15) < 0.3; // 30% de partículas en el núcleo
                    
                    // Radio variable según si es núcleo o región externa
                    let radius;
                    if (isCore) {
                        // Partículas del núcleo más concentradas
                        radius = Math.pow(this.pseudoRandom(seed + i * 10), 2.5) * nebulaSize * 0.3;
                    } else {
                        // Partículas externas más dispersas
                        radius = (0.3 + Math.pow(this.pseudoRandom(seed + i * 10), 1.2) * 0.7) * nebulaSize;
                    }
                    
                    // Forma esférica con aplastamiento
                    const theta = this.pseudoRandom(seed + i * 20) * Math.PI * 2;
                    const phi = this.pseudoRandom(seed + i * 30) * Math.PI;
                    
                    // Distorsión para crear forma de nebulosa - varía según el tamaño
                    // Las nebulosas pequeñas tienen menos distorsión para mantener forma compacta
                    const baseDistortion = sizeCategory < 0.33 ? 0.8 : 0.6;
                    const distortion = baseDistortion + this.pseudoRandom(seed + i * 40) * 
                                    (sizeCategory < 0.33 ? 0.4 : 0.8);
                    
                    // Coordenadas en polares
                    const x = radius * Math.sin(phi) * Math.cos(theta) * distortion;
                    const y = radius * Math.sin(phi) * Math.sin(theta) * 
                            (sizeCategory < 0.33 ? 0.7 : 0.5); // Menos aplastamiento para nebulosas pequeñas
                    const z = radius * Math.cos(phi) * distortion;
                    
                    // Posiciones
                    positions[i * 3] = x;
                    positions[i * 3 + 1] = y;
                    positions[i * 3 + 2] = z;
                    
                    // Ajustar color basado en si es núcleo o región externa
                    let lightness = baseLightness;
                    let particleHue = hue;
                    
                    if (isCore) {
                        // El núcleo es más brillante
                        lightness += 0.2;
                        // Pequeña variación de tono para el núcleo
                        particleHue = (hue + this.pseudoRandom(seed + i * 50) * 0.05) % 1.0;
                    } else {
                        // Más variación en tono para las partículas externas
                        particleHue = (hue + (this.pseudoRandom(seed + i * 50) - 0.5) * 0.15) % 1.0;
                    }
                    
                    const c = new THREE.Color().setHSL(particleHue, saturation, lightness);
                    colors[i * 3] = c.r;
                    colors[i * 3 + 1] = c.g;
                    colors[i * 3 + 2] = c.b;
                    
                    // Tamaños variables - ajustados según el tamaño de la nebulosa
                    const particleSizeFactor = sizeCategory < 0.33 ? 0.8 : (sizeCategory > 0.85 ? 1.3 : 1.0);
                    
                    if (isCore) {
                        sizes[i] = (3 + Math.pow(this.pseudoRandom(seed + i * 60), 2) * 12) * particleSizeFactor;
                    } else {
                        sizes[i] = (1.5 + Math.pow(this.pseudoRandom(seed + i * 60), 2) * 8) * particleSizeFactor;
                    }
                }
                
                nebulaGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                nebulaGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                nebulaGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                
                // Material para nebulosa
                const nebulaMaterial = new THREE.PointsMaterial({
                    size: 1.5,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.25,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true,
                    depthWrite: false
                });
                
                const nebula = new THREE.Points(nebulaGeometry, nebulaMaterial);
                
                // Rotación inicial aleatoria
                nebula.rotation.x = this.pseudoRandom(seed + 777) * Math.PI;
                nebula.rotation.y = this.pseudoRandom(seed + 888) * Math.PI;
                nebula.rotation.z = this.pseudoRandom(seed + 999) * Math.PI;
                
                // Posición dentro del cuadrante - ajustar según el tamaño
                // Las nebulosas grandes estarán más centradas para evitar cortes en los bordes
                const positionFactor = sizeCategory > 0.85 ? 0.5 : 0.8;
                const offsetX = (this.pseudoRandom(seed + 1111) - 0.5) * this.chunkSize * positionFactor;
                const offsetY = (this.pseudoRandom(seed + 2222) - 0.5) * this.chunkSize * positionFactor;
                const offsetZ = (this.pseudoRandom(seed + 3333) - 0.5) * this.chunkSize * positionFactor;
                nebula.position.set(offsetX, offsetY, offsetZ);
                
                // Añadir al cuadrante
                chunkObject.add(nebula);
                
                // Parámetros de animación - adaptados al tamaño
                // Las nebulosas más grandes se mueven más lentamente
                const speedFactor = sizeCategory > 0.85 ? 0.6 : (sizeCategory < 0.33 ? 1.3 : 1.0);
                
                const nebulaData = {
                    object: nebula,
                    // Velocidades de rotación escaladas por tamaño
                    rotationSpeed: {
                        x: (this.pseudoRandom(seed + 4444) - 0.5) * 0.002 * speedFactor,
                        y: (this.pseudoRandom(seed + 5555) - 0.5) * 0.002 * speedFactor,
                        z: (this.pseudoRandom(seed + 6666) - 0.5) * 0.002 * speedFactor
                    },
                    // Movimiento en elipse
                    movementPath: {
                        center: new THREE.Vector3(offsetX, offsetY, offsetZ),
                        amplitude: {
                            // Las amplitudes escalan con el tamaño - nebulosas más grandes tienen amplitudes mayores
                            x: (20 + this.pseudoRandom(seed + 7777) * 50) * (sizeCategory < 0.33 ? 0.7 : (sizeCategory > 0.85 ? 1.5 : 1.0)),
                            y: (20 + this.pseudoRandom(seed + 8888) * 50) * (sizeCategory < 0.33 ? 0.7 : (sizeCategory > 0.85 ? 1.5 : 1.0)),
                            z: (20 + this.pseudoRandom(seed + 9999) * 50) * (sizeCategory < 0.33 ? 0.7 : (sizeCategory > 0.85 ? 1.5 : 1.0))
                        },
                        phase: {
                            x: this.pseudoRandom(seed + 11111) * Math.PI * 2,
                            y: this.pseudoRandom(seed + 22222) * Math.PI * 2,
                            z: this.pseudoRandom(seed + 33333) * Math.PI * 2
                        },
                        speed: {
                            x: (this.pseudoRandom(seed + 44444) - 0.5) * 0.005 * speedFactor,
                            y: (this.pseudoRandom(seed + 55555) - 0.5) * 0.005 * speedFactor,
                            z: (this.pseudoRandom(seed + 66666) - 0.5) * 0.005 * speedFactor
                        }
                    }
                };
                
                // Añadir a la lista de nebulosas para animación
                this.nebulaeObjects.push(nebulaData);
            }
            
            // Animar todas las nebulosas (similar a la función original)
            animateNebulae() {
                const time = Date.now() * 0.001; // Tiempo en segundos para movimiento suave
                
                this.nebulaeObjects.forEach(nebulaData => {
                    const { object, rotationSpeed, movementPath } = nebulaData;
                    
                    // Aplicar rotación
                    object.rotation.x += rotationSpeed.x;
                    object.rotation.y += rotationSpeed.y;
                    object.rotation.z += rotationSpeed.z;
                    
                    // Movimiento en elipse alrededor del centro
                    object.position.x = movementPath.center.x + 
                        Math.sin(time * movementPath.speed.x + movementPath.phase.x) * movementPath.amplitude.x;
                    
                    object.position.y = movementPath.center.y + 
                        Math.cos(time * movementPath.speed.y + movementPath.phase.y) * movementPath.amplitude.y;
                    
                    object.position.z = movementPath.center.z + 
                        Math.sin(time * movementPath.speed.z + movementPath.phase.z) * movementPath.amplitude.z;
                });
            }
        }

        class HyperspaceEffect {
            constructor(scene, camera) {
                this.scene = scene;
                this.camera = camera;
                this.active = false;
                this.speedFactor = 1.0; // Factor normal de velocidad
                this.maxSpeedFactor = 10.0; // Velocidad máxima (10x)
                this.acceleration = 0.2; // Tasa de aceleración
                this.deceleration = 0.4; // Tasa de desaceleración (más rápida que la aceleración)
                this.targetSpeedFactor = 1.0;
                
                // Efecto de estrellas de velocidad
                this.speedLinesCount = 300;
                this.speedLinesObject = null;
                this.speedLinesVisible = false;
                
                // Sonido de hipervelocidad (opcional)
                this.hyperspaceSound = null;
                this.soundInitialized = false;
                
                // Crear el efecto visual
                this.createSpeedLines();
                
                // Opcionalmente inicializar sonido
                this.initializeSound();
            }
            
            // Activar/desactivar el modo hipervelocidad
            toggleHyperspace(enabled) {
                this.active = enabled;
                this.targetSpeedFactor = enabled ? this.maxSpeedFactor : 1.0;
                
                // Si está activo, mostrar las líneas de velocidad
                if (enabled && !this.speedLinesVisible) {
                    this.showSpeedLines();
                }
                
                // Activar/desactivar sonido
                if (this.soundInitialized) {
                    if (enabled && !this.hyperspaceSound.isPlaying) {
                        this.hyperspaceSound.play();
                    }
                }
            }
            
            // Actualizar el efecto (llamar desde el loop de animación)
            update(playerDirection) {
                // Ajustar velocidad actual gradualmente
                if (this.active && this.speedFactor < this.targetSpeedFactor) {
                    this.speedFactor += this.acceleration;
                    if (this.speedFactor > this.targetSpeedFactor) {
                        this.speedFactor = this.targetSpeedFactor;
                    }
                } else if (!this.active && this.speedFactor > this.targetSpeedFactor) {
                    this.speedFactor -= this.deceleration;
                    if (this.speedFactor < this.targetSpeedFactor) {
                        this.speedFactor = this.targetSpeedFactor;
                    }
                }
                
                // Si ya desaceleró completamente, ocultar las líneas de velocidad
                if (!this.active && this.speedFactor <= 1.1 && this.speedLinesVisible) {
                    this.hideSpeedLines();
                }
                
                // Actualizar el efecto visual de líneas de velocidad
                if (this.speedLinesVisible) {
                    this.updateSpeedLines(playerDirection);
                }
                
                // Actualizar sonido si está activo
                if (this.soundInitialized && this.hyperspaceSound.isPlaying) {
                    // Ajustar volumen y pitch basado en velocidad
                    const speedRatio = (this.speedFactor - 1.0) / (this.maxSpeedFactor - 1.0);
                    this.hyperspaceSound.volume = Math.min(0.7, speedRatio * 0.7);
                    
                    // Si ya no está en hipervelocidad y el sonido casi desaparece, detenerlo
                    if (!this.active && speedRatio < 0.1) {
                        this.hyperspaceSound.stop();
                    }
                }
                
                // Devolver el factor de velocidad actual para que sea usado por el movimiento
                return this.speedFactor;
            }
            
            // Crear las líneas de velocidad (inicialmente ocultas)
            createSpeedLines() {
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(this.speedLinesCount * 3);
                const colors = new Float32Array(this.speedLinesCount * 3);
                const sizes = new Float32Array(this.speedLinesCount);
                const speedParams = new Float32Array(this.speedLinesCount * 2); // Longitud y velocidad
                
                // Generar posiciones iniciales en forma de hemisferio delante del jugador
                for (let i = 0; i < this.speedLinesCount; i++) {
                    // Posición inicial aleatoria en un hemisferio
                    const theta = Math.random() * Math.PI * 2; // Ángulo horizontal
                    const phi = Math.random() * Math.PI / 2; // Ángulo vertical (solo hemisferio frontal)
                    const r = 5 + Math.random() * 95; // Radio entre 5 y 100
                    
                    // Coordenadas esféricas a cartesianas
                    positions[i * 3] = -r * Math.sin(phi) * Math.cos(theta);
                    positions[i * 3 + 1] = r * Math.cos(phi);
                    positions[i * 3 + 2] = -r * Math.sin(phi) * Math.sin(theta);
                    
                    // Color azulado con variación para efecto de velocidad
                    const blueIntensity = 0.5 + Math.random() * 0.5;
                    colors[i * 3] = 0.7; // R
                    colors[i * 3 + 1] = 0.8; // G
                    colors[i * 3 + 2] = blueIntensity; // B (azul más intenso)
                    
                    // Tamaño de la línea (variar para diversidad)
                    sizes[i] = 0.5 + Math.random() * 1.5;
                    
                    // Parámetros de velocidad y longitud
                    speedParams[i * 2] = 0.5 + Math.random() * 2.5; // Longitud de estela
                    speedParams[i * 2 + 1] = 0.5 + Math.random() * 1.5; // Velocidad relativa
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                
                // Crear textura para las líneas
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 16;
                const ctx = canvas.getContext('2d');
                
                // Dibujar línea con degradado
                const grd = ctx.createLinearGradient(0, 8, 64, 8);
                grd.addColorStop(0, "rgba(255, 255, 255, 1.0)");
                grd.addColorStop(1, "rgba(255, 255, 255, 0.0)");
                
                ctx.fillStyle = grd;
                ctx.fillRect(0, 0, 64, 16);
                
                const texture = new THREE.Texture(canvas);
                texture.needsUpdate = true;
                
                // Material para las líneas de velocidad
                const material = new THREE.PointsMaterial({
                    size: 2.0,
                    sizeAttenuation: true,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0,  // Inicialmente invisible
                    map: texture,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                // Crear el objeto y añadirlo a la escena (inicialmente invisible)
                this.speedLinesObject = new THREE.Points(geometry, material);
                this.speedLinesObject.frustumCulled = false; // Evitar que desaparezca fuera del frustum
                this.scene.add(this.speedLinesObject);
                
                // Guardar referencia a los atributos para animación
                this.speedLinesPositions = geometry.attributes.position;
                this.speedLinesColors = geometry.attributes.color;
                this.speedLinesSizes = geometry.attributes.size;
                this.speedParams = speedParams;
            }
            
            // Mostrar las líneas de velocidad con fade in
            showSpeedLines() {
                if (!this.speedLinesObject) return;
                this.speedLinesVisible = true;
                
                // Hacer aparecer gradualmente
                const material = this.speedLinesObject.material;
                const startOpacity = material.opacity;
                const targetOpacity = 0.7;
                const duration = 500; // ms
                const startTime = Date.now();
                
                const fadeIn = () => {
                    const elapsedTime = Date.now() - startTime;
                    const progress = Math.min(1.0, elapsedTime / duration);
                    
                    material.opacity = startOpacity + (targetOpacity - startOpacity) * progress;
                    
                    if (progress < 1.0) {
                        requestAnimationFrame(fadeIn);
                    }
                };
                
                fadeIn();
            }
            
            // Ocultar las líneas de velocidad con fade out
            hideSpeedLines() {
                if (!this.speedLinesObject) return;
                
                // Hacer desaparecer gradualmente
                const material = this.speedLinesObject.material;
                const startOpacity = material.opacity;
                const targetOpacity = 0.0;
                const duration = 500; // ms
                const startTime = Date.now();
                
                const fadeOut = () => {
                    const elapsedTime = Date.now() - startTime;
                    const progress = Math.min(1.0, elapsedTime / duration);
                    
                    material.opacity = startOpacity + (targetOpacity - startOpacity) * progress;
                    
                    if (progress < 1.0) {
                        requestAnimationFrame(fadeOut);
                    } else {
                        this.speedLinesVisible = false;
                    }
                };
                
                fadeOut();
            }
            
            // Actualizar la posición y apariencia de las líneas de velocidad
            updateSpeedLines(playerDirection) {
                if (!this.speedLinesObject || !this.speedLinesVisible) return;
                
                // Obtener la dirección en la que está mirando el jugador
                const forward = playerDirection.clone().normalize();
                
                // Crear un sistema de coordenadas local
                const up = new THREE.Vector3(0, 1, 0);
                const right = new THREE.Vector3().crossVectors(forward, up).normalize();
                up.crossVectors(right, forward);
                
                // Efecto incremental con velocidad
                const speedEffect = this.speedFactor / this.maxSpeedFactor;
                const positions = this.speedLinesPositions.array;
                const sizes = this.speedLinesSizes.array;
                const colors = this.speedLinesColors.array;
                
                for (let i = 0; i < this.speedLinesCount; i++) {
                    // Obtener posición actual
                    const px = positions[i * 3];
                    const py = positions[i * 3 + 1];
                    const pz = positions[i * 3 + 2];
                    
                    // Mover hacia atrás (efecto de estela)
                    const speed = this.speedParams[i * 2 + 1] * this.speedFactor * 0.2;
                    positions[i * 3] -= forward.x * speed;
                    positions[i * 3 + 1] -= forward.y * speed;
                    positions[i * 3 + 2] -= forward.z * speed;
                    
                    // Si la línea se fue muy lejos, reiniciarla al frente
                    const distanceToCamera = Math.sqrt(
                        px * px + py * py + pz * pz
                    );
                    
                    if (distanceToCamera > 120) {
                        // Nueva posición en un círculo delante del jugador
                        const angle = Math.random() * Math.PI * 2;
                        const radius = 5 + Math.random() * 15;
                        
                        positions[i * 3] = right.x * Math.cos(angle) * radius + 
                                        up.x * Math.sin(angle) * radius + 
                                        forward.x * (-10 - Math.random() * 20);
                                        
                        positions[i * 3 + 1] = right.y * Math.cos(angle) * radius + 
                                            up.y * Math.sin(angle) * radius + 
                                            forward.y * (-10 - Math.random() * 20);
                                            
                        positions[i * 3 + 2] = right.z * Math.cos(angle) * radius + 
                                            up.z * Math.sin(angle) * radius + 
                                            forward.z * (-10 - Math.random() * 20);
                    }
                    
                    // Ajustar tamaño basado en velocidad
                    sizes[i] = (0.5 + Math.random() * 0.5) * (1 + speedEffect * this.speedParams[i * 2] * 2);
                    
                    // Ajustar color (más azul a mayor velocidad)
                    colors[i * 3 + 2] = Math.min(1.0, 0.7 + speedEffect * 0.3);
                }
                
                // Marcar atributos para actualización
                this.speedLinesPositions.needsUpdate = true;
                this.speedLinesSizes.needsUpdate = true;
                this.speedLinesColors.needsUpdate = true;
                
                // Alinear con la cámara (estrategia de billboarding)
                this.speedLinesObject.quaternion.copy(this.camera.quaternion);
            }
            
            // Inicializar sonido (si Three.js Audio está disponible)
            initializeSound() {
                if (typeof THREE.Audio === 'undefined') return;
                
                try {
                    // Crear listener de audio y añadirlo a la cámara
                    const listener = new THREE.AudioListener();
                    this.camera.add(listener);
                    
                    // Crear fuente de sonido
                    this.hyperspaceSound = new THREE.Audio(listener);
                    
                    // Crear buffer de audio con ruido blanco filtrado
                    const context = listener.context;
                    const bufferSize = 2 * context.sampleRate;
                    const buffer = context.createBuffer(1, bufferSize, context.sampleRate);
                    const data = buffer.getChannelData(0);
                    
                    // Generar ruido con más bajas frecuencias (tipo "whoosh")
                    let lastOut = 0.0;
                    for (let i = 0; i < bufferSize; i++) {
                        // Ruido blanco filtrado para efecto de viento espacial
                        const white = Math.random() * 2 - 1;
                        // Filtro paso bajo simple
                        lastOut = (lastOut + (0.02 * white)) / 1.02;
                        data[i] = lastOut * 3.5; // Amplificación
                    }
                    
                    // Configurar el sonido
                    this.hyperspaceSound.setBuffer(buffer);
                    this.hyperspaceSound.setLoop(true);
                    this.hyperspaceSound.setVolume(0);
                    
                    this.soundInitialized = true;
                } catch (e) {
                    console.error("Error initializing hyperspace sound:", e);
                }
            }
            
            // Limpiar recursos al destruir
            dispose() {
                if (this.speedLinesObject) {
                    if (this.speedLinesObject.geometry) {
                        this.speedLinesObject.geometry.dispose();
                    }
                    if (this.speedLinesObject.material) {
                        if (this.speedLinesObject.material.map) {
                            this.speedLinesObject.material.map.dispose();
                        }
                        this.speedLinesObject.material.dispose();
                    }
                    this.scene.remove(this.speedLinesObject);
                }
                
                if (this.hyperspaceSound && this.hyperspaceSound.isPlaying) {
                    this.hyperspaceSound.stop();
                }
            }
        }

        function createSharperCircleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128;  // Mayor resolución para más nitidez
            canvas.height = 128;
            
            const context = canvas.getContext('2d');
            
            // Fondo transparente
            context.fillStyle = 'rgba(0,0,0,0)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = canvas.width / 2 - 2;
            
            // Degradado radial con borde más definido
            const gradient = context.createRadialGradient(
                centerX, centerY, 0,
                centerX, centerY, radius
            );
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.7, 'rgba(255,255,255,0.9)'); // Mayor opacidad hasta más lejos
            gradient.addColorStop(0.9, 'rgba(255,255,255,0.3)'); // Caída más rápida al final
            gradient.addColorStop(1, 'rgba(255,255,255,0)');
            
            // Dibujar círculo con degradado
            context.beginPath();
            context.arc(centerX, centerY, radius, 0, Math.PI * 2, false);
            context.fillStyle = gradient;
            context.fill();
            
            // Añadir un resplandor central para más brillo
            const innerGradient = context.createRadialGradient(
                centerX, centerY, 0,
                centerX, centerY, radius * 0.5
            );
            innerGradient.addColorStop(0, 'rgba(255,255,255,0.8)');
            innerGradient.addColorStop(1, 'rgba(255,255,255,0)');
            
            context.beginPath();
            context.arc(centerX, centerY, radius * 0.5, 0, Math.PI * 2, false);
            context.fillStyle = innerGradient;
            context.fill();
            
            // Crear textura
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            
            return texture;
        }

        // Añade esta función al inicio del archivo (después de las variables principales)
        function createCircleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            
            const context = canvas.getContext('2d');
            
            // Fondo transparente
            context.fillStyle = 'rgba(0,0,0,0)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            // Dibujar círculo con degradado radial para bordes suaves
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = canvas.width / 2 - 2;  // -2 para dejar un poco de margen
            
            // Crear degradado radial
            const gradient = context.createRadialGradient(
                centerX, centerY, 0,
                centerX, centerY, radius
            );
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.8, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(1, 'rgba(255,255,255,0)');
            
            // Dibujar círculo con el degradado
            context.beginPath();
            context.arc(centerX, centerY, radius, 0, Math.PI * 2, false);
            context.fillStyle = gradient;
            context.fill();
            
            // Crear textura
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            
            return texture;
        }
            
        // Función para crear una textura circular con bordes más nítidos
        function createSharperCircleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            
            const context = canvas.getContext('2d');
            
            // Fondo transparente
            context.fillStyle = 'rgba(0,0,0,0)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = canvas.width / 2 - 2;
            
            // Degradado radial con borde más definido
            const gradient = context.createRadialGradient(
                centerX, centerY, 0,
                centerX, centerY, radius
            );
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.7, 'rgba(255,255,255,0.9)');
            gradient.addColorStop(0.9, 'rgba(255,255,255,0.3)');
            gradient.addColorStop(1, 'rgba(255,255,255,0)');
            
            context.beginPath();
            context.arc(centerX, centerY, radius, 0, Math.PI * 2, false);
            context.fillStyle = gradient;
            context.fill();
            
            // Añadir un resplandor central para más brillo
            const innerGradient = context.createRadialGradient(
                centerX, centerY, 0,
                centerX, centerY, radius * 0.5
            );
            innerGradient.addColorStop(0, 'rgba(255,255,255,0.8)');
            innerGradient.addColorStop(1, 'rgba(255,255,255,0)');
            
            context.beginPath();
            context.arc(centerX, centerY, radius * 0.5, 0, Math.PI * 2, false);
            context.fillStyle = innerGradient;
            context.fill();
            
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            
            return texture;
        }

        
        // Objetos para la cámara
        let avatarObject;
        let cameraTarget = new THREE.Vector3();
        let cameraOffset = new THREE.Vector3(0, 10, 20);
        let currentViewMode = 'thirdPerson';
        
        // Variables de control del mouse
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let mouseSensitivity = 0.003;
        
        // Variables MIDI
        let midiAccess = null;
        let activeInputs = new Set();
        let midiStatusElement = document.getElementById('midiStatus');
        let coordsElement = document.getElementById('coordinates');
        
        // Variables de red
        let username = "Explorador" + Math.floor(Math.random() * 1000);
        let otherPlayers = {};
        
        // Configuración física mejorada de galaxias
        const GALAXY_CONFIG = {
            particleCount: 8000,        // Más partículas para mejor efecto
            maxSize: 80,               // Mayor tamaño máximo
            coreIntensity: 1.5,        // Más brillo en el núcleo
            expansionRate: 0.025,      // Velocidad de expansión
            rotationSpeed: 0.0008,     // Rotación
            fadeRate: 0.002,           // Desvanecimiento
            spiralFactor: 3.5,         // Factor espiral más pronunciado
            armCount: 5,               // Brazos
            armWidth: 0.4,             // Ancho de brazos
            viewingDistance: 30,       // Distancia de visualización
            interactionDistance: 2.0,  // Distancia para mezcla de colores entre partículas
            sphereQuality: 8,          // Calidad de las esferas (segmentos)
            mixingIntensity: 0.3       // Intensidad de la mezcla de colores (0-1)
        };
        // Configuración mejorada para galaxias de píxeles
        const GALAXY_PIXEL_CONFIG = {
            particleCount: 10000,        // Más partículas para mayor riqueza visual
            size: 0.5,                  // Tamaño de los píxeles
            spiralFactor: 4.5,          // Factor espiral más pronunciado
            armCount: 4,                // Número de brazos de la galaxia
            colorVariety: [
                // Paleta de colores inspirada en nebulosas y galaxias reales
                {name: "Azul Profundo", hue: 0.6, sat: 0.8, light: 0.4},
                {name: "Violeta Cósmico", hue: 0.75, sat: 0.7, light: 0.45},
                {name: "Turquesa Espacial", hue: 0.55, sat: 0.6, light: 0.5},
                {name: "Rosa Magenta", hue: 0.9, sat: 0.7, light: 0.5},
                {name: "Verde Esmeralda", hue: 0.4, sat: 0.6, light: 0.45},
                {name: "Naranja Cálido", hue: 0.08, sat: 0.8, light: 0.5},
            ],
            mixingIntensity: 0.4,       // Intensidad de mezcla de colores
            expansionTime: 5000,        // Tiempo de expansión de la galaxia
            rotationSpeed: 0.005,       // Velocidad de rotación
            lifetime: 30000             // Tiempo de vida de la galaxia
        };
        
        // Clase para partícula individual
        // 1. SOLUCIÓN PARA EL CONGELAMIENTO DE ANIMACIÓN
        // 1. SOLUCIÓN PARA EL CONGELAMIENTO DE ANIMACIÓN
        // El problema probablemente está en la gestión de la memoria y los objetos
        // Modifica la clase PixelGalaxy para garantizar una limpieza adecuada

        // ---------- Clase PixelGalaxy (actualizada) ------------
        class PixelGalaxy {
            constructor(id, initialPosition) {
                this.id = id;
                this.position = initialPosition.clone();
                this.creationTime = Date.now();
                this.geometry = new THREE.BufferGeometry();
                this.isFadingOut = false;
                this.fadeOutStartTime = 0;
                this.lastUpdateTime = Date.now();
                this.lastNoteTime = Date.now();
                this.isDisposed = false;
                this.pulsePhase = 0;
                this.armRotation = 0; // Controla la rotación global de los brazos
                this.activeNotes = {};
                this.fullyExpanded = false; // Flag para controlar si ya se expandió completamente

                // Nuevo: Color predominante para toda la galaxia
                // Elegimos un color base coherente en lugar de variedad de colores
                const colorSchemes = [
                { name: "Azul Nebulosa", baseHue: 0.6, variation: 0.03 },
                { name: "Púrpura Espacial", baseHue: 0.75, variation: 0.03 },
                { name: "Verde Cósmico", baseHue: 0.35, variation: 0.04 },
                { name: "Rojo Estelar", baseHue: 0.0, variation: 0.03 },
                { name: "Ámbar Solar", baseHue: 0.12, variation: 0.03 },
                { name: "Turquesa Profundo", baseHue: 0.48, variation: 0.03 }
                ];
                
                // Seleccionar un esquema de color aleatorio
                this.colorScheme = colorSchemes[Math.floor(Math.random() * colorSchemes.length)];

                // Obtener configuración personalizada si existe
                let customSettings = {};
                try {
                const savedSettings = localStorage.getItem('musicosmosGalaxySettings');
                if (savedSettings) {
                    customSettings = JSON.parse(savedSettings);
                }
                } catch (e) {
                console.error('Error al cargar configuración de galaxia:', e);
                }

                // Configuración combinada
                this.config = {
                particleCount: 7000,
                baseSize: 0.3,
                expansionSpeed: 0.0008,
                spiralSpeed: 0.0008,
                armRotationSpeed: 0.00015,
                pulseSpeed: 0.02,
                // Valores que pueden ser personalizados
                maxExpansion: customSettings.size || 25,
                particleAffectedRatio: (customSettings.particleCount || 12) / 100,
                colorMixFactor: (customSettings.colorMixing || 50) / 100,
                expansionTime: customSettings.expansionTime || 4000,
                inactivityTime: customSettings.fadeoutTime || 20000,
                // Otros valores
                lifeTime: 25000,
                fadeOutTime: 5000,
                verticalScale: 0.9,
                responseSpeed: 0.3,
                // Usar un único esquema de color predominante
                baseHue: this.colorScheme.baseHue,
                colorVariation: this.colorScheme.variation,
                // Historial de notas para transición cromática
                noteHistory: [],
                maxHistoryLength: 10
                };

                this.createGalaxy();
                this.createNebulaCore();
            }

            createGalaxy() {
                const particleCount = this.config.particleCount;
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                const sizes = new Float32Array(particleCount);
                const nebulaParams = new Float32Array(particleCount * 4);
                
                // Hue base para toda la galaxia (color predominante)
                const baseHue = this.config.baseHue;
                
                for (let i = 0; i < particleCount; i++) {
                // Generar un radio aleatorio con sesgo y un ángulo base aleatorio
                const distFromCenter = Math.pow(Math.random(), 0.5) * this.config.maxExpansion;
                const baseAngle = Math.random() * Math.PI * 2;
                const speedVar = Math.random();
                const phaseOffset = Math.random() * Math.PI * 2;
                
                nebulaParams[i * 4] = distFromCenter;
                nebulaParams[i * 4 + 1] = baseAngle;
                nebulaParams[i * 4 + 2] = speedVar;
                nebulaParams[i * 4 + 3] = phaseOffset;
                
                // Posición inicial concentrada
                positions[i * 3] = (Math.random() - 0.5) * 0.2;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 0.1;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 0.2;
                
                // Pequeña variación sutil en el color (dentro del mismo tono)
                const hueVar = (Math.random() - 0.5) * this.config.colorVariation;
                const saturation = 0.7 + Math.random() * 0.3; // Alta saturación
                const lightness = 0.4 + Math.random() * 0.2; // Brillo moderado
                
                // Aplicar color con pequeña variación pero mismo tono base
                const color = new THREE.Color().setHSL(
                    (baseHue + hueVar) % 1.0, 
                    saturation, 
                    lightness
                );
                
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
                
                sizes[i] = this.config.baseSize * (0.6 + Math.random() * 0.6);
                }
                
                this.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                this.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                this.geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                this.nebulaParams = nebulaParams;
                
                // Usar textura circular nítida
                const circleTexture = createSharperCircleTexture();
                const material = new THREE.PointsMaterial({
                size: this.config.baseSize,
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                map: circleTexture,
                alphaTest: 0.05
                });
                
                this.pixelObject = new THREE.Points(this.geometry, material);
                this.pixelObject.position.copy(this.position);
                scene.add(this.pixelObject);
            }

            createNebulaCore() {
                if (!avatarObject) return;
                
                // Shaders para efectos de glow mejorados
                const glowVertexShader = `
                varying vec3 vNormal;
                varying vec3 vViewPosition;
                
                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    vViewPosition = -mvPosition.xyz;
                    gl_Position = projectionMatrix * mvPosition;
                }
                `;
                
                const glowFragmentShader = `
                uniform vec3 glowColor;
                uniform float pulseIntensity;
                uniform float timeFactor;
                
                varying vec3 vNormal;
                varying vec3 vViewPosition;
                
                void main() {
                    // Calcular intensidad basada en ángulo de visión
                    float intensity = pow(0.7 - dot(normalize(vViewPosition), vNormal), 2.0);
                    // Añadir efecto de pulso
                    intensity *= 1.0 + 0.3 * sin(timeFactor);
                    // Aplicar intensidad de pulso global
                    intensity *= pulseIntensity;
                    
                    gl_FragColor = vec4(glowColor, 1.0) * intensity;
                }
                `;
                
                // Guardar material original
                this.originalAvatarMaterial = avatarObject.material.clone();
                
                // Crear shader personalizado para el avatar
                const avatarUniforms = {
                glowColor: { value: new THREE.Color(0x4488ff) },
                pulseIntensity: { value: 1.0 },
                timeFactor: { value: 0.0 }
                };
                
                const avatarMaterial = new THREE.ShaderMaterial({
                uniforms: avatarUniforms,
                vertexShader: glowVertexShader,
                fragmentShader: glowFragmentShader,
                transparent: true,
                blending: THREE.AdditiveBlending,
                side: THREE.FrontSide
                });
                
                avatarObject.material = avatarMaterial;
                this.avatarUniforms = avatarUniforms;
                
                // Inner glow mejorado con shaders
                const innerGlowGeometry = new THREE.SphereGeometry(1.05, 24, 24);
                const innerGlowUniforms = {
                glowColor: { value: new THREE.Color(0xccffff) },
                pulseIntensity: { value: 0.8 },
                timeFactor: { value: 0.0 }
                };
                
                const innerGlowMaterial = new THREE.ShaderMaterial({
                uniforms: innerGlowUniforms,
                vertexShader: glowVertexShader,
                fragmentShader: glowFragmentShader,
                transparent: true,
                blending: THREE.AdditiveBlending
                });
                
                this.innerGlow = new THREE.Mesh(innerGlowGeometry, innerGlowMaterial);
                this.innerGlowUniforms = innerGlowUniforms;
                avatarObject.add(this.innerGlow);
                
                // Outer glow expansivo con shader
                const outerGlowGeometry = new THREE.SphereGeometry(this.config.maxExpansion / 10, 24, 24);
                const outerGlowUniforms = {
                glowColor: { value: new THREE.Color(0x3366ff) },
                pulseIntensity: { value: 0.4 },
                timeFactor: { value: 0.0 }
                };
                
                const outerGlowMaterial = new THREE.ShaderMaterial({
                uniforms: outerGlowUniforms,
                vertexShader: glowVertexShader,
                fragmentShader: glowFragmentShader,
                transparent: true,
                blending: THREE.AdditiveBlending,
                side: THREE.BackSide
                });
                
                this.outerGlowEffect = new THREE.Mesh(outerGlowGeometry, outerGlowMaterial);
                this.outerGlowUniforms = outerGlowMaterial.uniforms;
                avatarObject.add(this.outerGlowEffect);
                
                // Luz central sutil
                this.coreLight = new THREE.PointLight(0xffffff, 1.0, 15);
                this.coreLight.position.set(0, 0, 0);
                avatarObject.add(this.coreLight);
            }

            pulseCore(note, velocity) {
                if (!this.innerGlow || !this.outerGlowEffect || !this.coreLight) return;
                
                const now = Date.now();
                this.lastNoteTime = now;
                
                // Mapeo de nota MIDI a color (0-127 -> 0-1 en hue)
                const noteHue = (note % 12) / 12;
                const octave = Math.floor(note / 12) - 1;
                
                // Registrar o actualizar nota en activeNotes
                if (!this.activeNotes[note]) {
                    // Nueva nota
                    this.activeNotes[note] = {
                    velocity: velocity,
                    startTime: now,
                    duration: 0,
                    lastUpdateTime: now,
                    color: new THREE.Color().setHSL(
                        noteHue, 
                        0.85, 
                        0.55 + (octave / 8) * 0.25
                    )
                    };
                } else {
                    // Nota ya activa, actualizar
                    this.activeNotes[note].lastUpdateTime = now;
                    // Calcular duración acumulada
                    this.activeNotes[note].duration += now - this.activeNotes[note].lastUpdateTime;
                    this.activeNotes[note].velocity = velocity; // Actualizar velocidad
                }
                
                // Calcular color basado en la nota
                const noteColor = new THREE.Color().setHSL(
                    noteHue, 
                    0.85, 
                    0.55 + (octave / 8) * 0.25
                );
                
                const intensity = 0.7 + (velocity / 127) * 1.3;
                
                // Actualizar uniforms del shader del avatar
                if (this.avatarUniforms) {
                    this.avatarUniforms.glowColor.value = noteColor;
                    this.avatarUniforms.pulseIntensity.value = intensity;
                    this.avatarUniforms.timeFactor.value = now * 0.003;
                }
                
                // Inner glow: mezcla con blanco usando uniforms
                if (this.innerGlowUniforms) {
                    const mixedColor = new THREE.Color(0xffffff).lerp(noteColor, 0.4);
                    this.innerGlowUniforms.glowColor.value = mixedColor;
                    this.innerGlowUniforms.pulseIntensity.value = 0.2 + (velocity / 127) * 0.2;
                    this.innerGlowUniforms.timeFactor.value = now * 0.003;
                }
                
                // Outer glow con uniforms
                if (this.outerGlowUniforms) {
                    this.outerGlowUniforms.glowColor.value = noteColor;
                    this.outerGlowUniforms.pulseIntensity.value = 0.2 + (velocity / 127) * 0.2;
                    this.outerGlowUniforms.timeFactor.value = now * 0.002;
                }
                
                // Luz central
                if (this.coreLight) {
                    this.coreLight.color = noteColor;
                    this.coreLight.intensity = 0.8 + intensity * 0.4;
                    this.coreLight.distance = 10 + (velocity / 127) * 10;
                }
                
                // Si esta nota se ha sostenido por mucho tiempo o tocado repetidamente,
                // actualizar una variable de control
                this.updateDominantNote();
                }

                // Agregar método para encontrar la nota dominante
                updateDominantNote() {
                const now = Date.now();
                let maxDuration = 0;
                let mostPlayedNote = null;
                
                // Buscar nota sostenida más tiempo o tocada más veces
                for (const noteId in this.activeNotes) {
                    const note = this.activeNotes[noteId];
                    
                    // Calcular duración acumulada
                    const noteDuration = note.duration + (now - note.lastUpdateTime);
                    
                    if (noteDuration > maxDuration) {
                    maxDuration = noteDuration;
                    mostPlayedNote = noteId;
                    }
                }
                
                // Si hay una nota dominante que supera un umbral (3 segundos)
                const dominanceThreshold = 3000; // 3 segundos
                if (maxDuration > dominanceThreshold && mostPlayedNote) {
                    this.dominantNote = parseInt(mostPlayedNote);
                    this.dominantNoteIntensity = Math.min(1, maxDuration / 10000); // Máximo en 10 segundos
                } else {
                    this.dominantNoteIntensity = this.dominantNoteIntensity ? 
                    Math.max(0, this.dominantNoteIntensity - 0.01) : 0; // Disminuir gradualmente
                }
                }

                addParticles(note, velocity) {
                    if (!this.pixelObject || !this.pixelObject.geometry || this.isDisposed) return;
                    
                    // Si estaba desvaneciéndose, cancelar el desvanecimiento
                    if (this.isFadingOut) {
                        this.isFadingOut = false;
                        if (this.pixelObject.material) {
                            this.pixelObject.material.opacity = 0.9; // Restaurar opacidad
                        }
                    }
                    
                    // Activar efectos del núcleo según nota MIDI
                    this.pulseCore(note, velocity);
                    this.lastNoteTime = Date.now();
                    
                    // Mapeo de nota a tono de color
                    const noteHue = (note % 12) / 12;
                    const octave = Math.floor(note / 12) - 1;
                    const noteColor = new THREE.Color().setHSL(
                        noteHue, 
                        0.85, 
                        0.55 + (octave / 8) * 0.25
                    );
                    
                    // Modificar el tamaño de expansión basado en la velocidad
                    // Rango de expansión: 15 (mínimo) a 50 (máximo)
                    const dynamicExpansion = 15 + (velocity / 127) * 35;
                    this.config.maxExpansion = dynamicExpansion;
                    
                    const positions = this.geometry.attributes.position;
                    const colors = this.geometry.attributes.color;
                    
                    // Mayor cantidad de partículas para respuesta más rápida
                    // Usar ratio personalizado y velocidad
                    const transformCount = Math.floor(positions.count * this.config.particleAffectedRatio * (velocity / 127));
                    
                    // Transformar un subconjunto de partículas
                    for (let i = 0; i < transformCount; i++) {
                        // Elegir partícula aleatoria
                        const idx = Math.floor(Math.random() * positions.count);
                        
                        // Transformar color gradualmente
                        const currentColor = new THREE.Color(
                            colors.array[idx * 3],
                            colors.array[idx * 3 + 1],
                            colors.array[idx * 3 + 2]
                        );
                        
                        // Mezcla más agresiva hacia el nuevo color para respuesta más rápida
                        const baseFactor = this.config.colorMixFactor;
                        const mixFactor = baseFactor + (velocity / 127) * (baseFactor * 0.8);
                        const newColor = currentColor.lerp(noteColor, mixFactor);
                        
                        colors.array[idx * 3] = newColor.r;
                        colors.array[idx * 3 + 1] = newColor.g;
                        colors.array[idx * 3 + 2] = newColor.b;
                    }
                    
                    // Marcar colores para actualización
                    colors.needsUpdate = true;
                    
                    // Extender la vida de la galaxia
                    this.creationTime = Math.min(this.creationTime, Date.now() - 5000); // Mantener expansión
                }

            update() {
                if (this.isDisposed || !this.pixelObject) return false;
                
                const now = Date.now();
                const deltaTime = now - this.lastUpdateTime;
                this.lastUpdateTime = now;
                
                if (deltaTime > 1000) return true;
                
                // Actualizar factor de tiempo para shaders
                if (this.avatarUniforms) {
                this.avatarUniforms.timeFactor.value = now * 0.003;
                }
                if (this.innerGlowUniforms) {
                this.innerGlowUniforms.timeFactor.value = now * 0.003;
                }
                if (this.outerGlowUniforms) {
                this.outerGlowUniforms.timeFactor.value = now * 0.002;
                }
                
                const age = now - this.creationTime;
                const timeSinceLastNote = now - this.lastNoteTime;
                
                // Usar tiempo de expansión personalizado
                let normalizedAge = Math.min(1, age / this.config.expansionTime);
                
                // Si ya se expandió completamente una vez, mantenerla expandida
                if (normalizedAge >= 1) {
                this.fullyExpanded = true;
                }
                
                // Si está completamente expandida, mantener la expansión
                if (this.fullyExpanded) {
                normalizedAge = 1;
                }
                
                // Incrementar el pulso y la rotación global de los brazos
                this.pulsePhase += this.config.pulseSpeed * deltaTime / 1000;
                this.armRotation += this.config.armRotationSpeed * deltaTime;
                const pulseValue = 0.5 + Math.sin(this.pulsePhase) * 0.5;
                
                // Usar un factor de expansión basado en normalizedAge
                const maxScale = this.config.maxExpansion / 20;
                const currentScale = Math.min(maxScale, normalizedAge * maxScale);
                const positions = this.geometry.attributes.position;
                const sizes = this.geometry.attributes.size;
                
                // Actualizar cada partícula para lograr un efecto espiral animado
                for (let i = 0; i < positions.count; i++) {
                const dist = this.nebulaParams[i * 4] * currentScale;
                const baseAngle = this.nebulaParams[i * 4 + 1];
                const speedVar = this.nebulaParams[i * 4 + 2];
                const phaseVar = this.nebulaParams[i * 4 + 3];
                
                // Calcular rotación diferencial y sumar la rotación global (se resta para invertir sentido)
                const rotationIncrement = this.config.spiralSpeed * deltaTime * (0.5 + speedVar);
                const angle = baseAngle + rotationIncrement - this.armRotation + Math.sin(this.pulsePhase * 0.2 + phaseVar * 10) * 0.1;
                
                // Onda radial
                const wavePhase = this.pulsePhase * 0.3 + phaseVar * Math.PI * 2;
                const waveMagnitude = 0.25 * speedVar * dist;
                const orbitRadius = dist * (0.7 + Math.sin(wavePhase) * 0.3);
                
                positions.array[i * 3] = Math.cos(angle) * orbitRadius + Math.cos(wavePhase * 1.5) * waveMagnitude;
                positions.array[i * 3 + 2] = Math.sin(angle) * orbitRadius + Math.sin(wavePhase * 1.5) * waveMagnitude;
                
                // Componente Y para dar volumen
                const yOffset = speedVar * currentScale * this.config.verticalScale;
                const yWave = Math.sin(wavePhase + angle) * waveMagnitude * 0.8;
                positions.array[i * 3 + 1] = yOffset + yWave;
                
                // Tamaño con pulso
                const pulseFactor = 1 + pulseValue * 0.1 * (0.5 + phaseVar);
                sizes.array[i] = this.config.baseSize * (0.5 + normalizedAge * 0.5) * pulseFactor;
                }
                
                positions.needsUpdate = true;
                sizes.needsUpdate = true;
                
                // Manejo del fade out - usar tiempo de inactividad personalizado
                if (this.isFadingOut) {
                const fadeOutDuration = this.config.fadeOutTime;
                const timeSinceFade = now - this.fadeOutStartTime;
                const opacity = Math.max(0, 1 - (timeSinceFade / fadeOutDuration));
                
                if (this.pixelObject && this.pixelObject.material) {
                    this.pixelObject.material.opacity = opacity;
                    
                    // Solo eliminar después de un tiempo mucho mayor sin interacción
                    if (opacity <= 0 && timeSinceLastNote > 30000) {
                    scene.remove(this.pixelObject);
                    this.dispose();
                    return false;
                    }
                }
                } else if (timeSinceLastNote > this.config.inactivityTime) {  // Usar tiempo personalizado
                this.isFadingOut = true;
                this.fadeOutStartTime = now;
                }
                
                return true;
            }

            removeNote(note) {
                if (this.isDisposed) return;
                delete this.activeNotes[note];
                if (Object.keys(this.activeNotes).length === 0 && Date.now() - this.lastNoteTime > 15000) {
                if (!this.isFadingOut) {
                    this.isFadingOut = true;
                    this.fadeOutStartTime = Date.now();
                }
                }
            }

            dispose() {
                if (this.isDisposed) return;
                this.isDisposed = true;
                
                // Desvanecimiento gradual del halo del avatar
                const startTime = Date.now();
                const fadeDuration = 2000; // 2 segundos de desvanecimiento
                
                const fadeOutAvatarGlow = () => {
                const now = Date.now();
                const elapsed = now - startTime;
                const progress = Math.min(1, elapsed / fadeDuration);
                
                // Reducir gradualmente la intensidad del shader del avatar
                if (this.avatarUniforms && this.avatarUniforms.pulseIntensity) {
                    this.avatarUniforms.pulseIntensity.value = 1.0 * (1 - progress);
                }
                
                // Reducir la intensidad del inner glow
                if (this.innerGlowUniforms && this.innerGlowUniforms.pulseIntensity) {
                    this.innerGlowUniforms.pulseIntensity.value = 0.8 * (1 - progress);
                }
                
                // Reducir la intensidad del outer glow
                if (this.outerGlowUniforms && this.outerGlowUniforms.pulseIntensity) {
                    this.outerGlowUniforms.pulseIntensity.value = 0.4 * (1 - progress);
                }
                
                // Reducir la intensidad de la luz
                if (this.coreLight) {
                    this.coreLight.intensity = 1.0 * (1 - progress);
                }
                
                if (progress < 1) {
                    // Continuar el desvanecimiento
                    requestAnimationFrame(fadeOutAvatarGlow);
                } else {
                    // Completar la limpieza una vez finalizado el desvanecimiento
                    this.completeDispose();
                }
                };
                
                // Iniciar el desvanecimiento
                fadeOutAvatarGlow();
            }
            
            // Método para completar la limpieza después del desvanecimiento
            completeDispose() {
                if (this.originalAvatarMaterial && avatarObject) {
                avatarObject.material = this.originalAvatarMaterial;
                this.originalAvatarMaterial = null;
                }
                
                if (this.innerGlow && avatarObject) {
                avatarObject.remove(this.innerGlow);
                this.innerGlow.material.dispose();
                this.innerGlow.geometry.dispose();
                this.innerGlow = null;
                }
                
                if (this.outerGlowEffect && avatarObject) {
                avatarObject.remove(this.outerGlowEffect);
                this.outerGlowEffect.material.dispose();
                this.outerGlowEffect.geometry.dispose();
                this.outerGlowEffect = null;
                }
                
                if (this.coreLight && avatarObject) {
                avatarObject.remove(this.coreLight);
                this.coreLight = null;
                }
                
                if (this.pixelObject) {
                scene.remove(this.pixelObject);
                if (this.pixelObject.geometry) this.pixelObject.geometry.dispose();
                if (this.pixelObject.material) {
                    if (this.pixelObject.material.map) this.pixelObject.material.map.dispose();
                    this.pixelObject.material.dispose();
                }
                this.pixelObject = null;
                }
                
                this.geometry = null;
                this.nebulaParams = null;
                this.avatarUniforms = null;
                this.innerGlowUniforms = null;
                this.outerGlowUniforms = null;
            }
            }
        
        // Clase Galaxy para manejar conjuntos de partículas
        // Modificar el método addNote en la clase Galaxy para usar PixelGalaxy
       // ---------- Clase Galaxy (actualizada) ------------
        class Galaxy {
            constructor(id, initialPosition) {
                this.id = id;
                this.position = initialPosition.clone();
                this.pixelGalaxy = null;
                this.activeNotes = new Map();
                this.energy = 0;
                this.lastNoteTime = Date.now();
                this.isDisposed = false;
            }

            addNote(note, velocity) {
                if (this.isDisposed) return;
                this.activeNotes.set(note, { velocity: velocity, time: Date.now() });
                this.energy = Math.min(1.0, this.energy + (velocity / 127) * 0.2);
                this.lastNoteTime = Date.now();
                if (!this.pixelGalaxy) {
                this.pixelGalaxy = new PixelGalaxy(this.id, this.position);
                }
                if (this.pixelGalaxy) {
                this.pixelGalaxy.addParticles(note, velocity);
                }
            }

            removeNote(note) {
                if (this.isDisposed) return;
                this.activeNotes.delete(note);
                if (this.activeNotes.size === 0 && Date.now() - this.lastNoteTime > 10000) {
                if (this.pixelGalaxy && !this.pixelGalaxy.isFadingOut) {
                    this.pixelGalaxy.isFadingOut = true;
                    this.pixelGalaxy.fadeOutStartTime = Date.now();
                }
                }
            }

            update() {
                if (this.isDisposed) return;
                if (this.pixelGalaxy) {
                const result = this.pixelGalaxy.update();
                if (!result) {
                    this.pixelGalaxy = null;
                }
                }
                const now = Date.now();
                if (now - this.lastNoteTime > 2000) {
                this.energy = Math.max(0, this.energy - 0.005);
                }
            }

            updatePosition(newPos) {
                if (this.isDisposed) return;
                this.position.copy(newPos);
                if (this.pixelGalaxy && this.pixelGalaxy.pixelObject) {
                this.pixelGalaxy.pixelObject.position.copy(newPos);
                }
            }

            dispose() {
                if (this.isDisposed) return;
                this.isDisposed = true;
                if (this.pixelGalaxy) {
                this.pixelGalaxy.dispose();
                this.pixelGalaxy = null;
                }
                this.activeNotes.clear();
            }
            }

        // Sistema de hipervelocidad para Musicosmos



        function init() {
            // Crear escena
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000011);
            scene.fog = new THREE.FogExp2(0x000011, 0.0004); // Niebla más sutil
            
            // Añadir efecto de bloom para mejor apariencia
            const renderScene = new THREE.Scene();
            
            // Configurar cámara
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 20);
            
            // Crear renderer
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limitar para mejor rendimiento
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // Iluminación ambiental
            const ambientLight = new THREE.AmbientLight(0x101020);
            scene.add(ambientLight);

            // Luz direccional principal
            const directionalLight = new THREE.DirectionalLight(0x3333ff, 0.4);
            directionalLight.position.set(1, 1, 1);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Luz complementaria
            const backLight = new THREE.DirectionalLight(0x5544ee, 0.2);
            backLight.position.set(-1, -1, -1);
            scene.add(backLight);

            // Crear plano cartesiano con cuadrícula
            gridHelper = new THREE.GridHelper(1000, 100, 0x333366, 0x222244);
            scene.add(gridHelper);

            // Crear avatar para representar al usuario
            createAvatar();
            
            // Crear fondo estelar
            //createStarBackground(); - 
            proceduralGenerator = new ProceduralGenerator(scene);
            hyperspaceEffect = new HyperspaceEffect(scene, camera);


            // Crear galaxia personal
            galaxies[username] = new Galaxy(username, avatarObject.position.clone());

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            
            // Mejorado: Ahora usamos mousedown en el documento, pero verificamos si fue en el menú
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('wheel', onMouseWheel);
            
            // Prevenir que los clics en el menú cierren el arrastre
            document.getElementById('settingsMenu').addEventListener('mousedown', function(event) {
                event.stopPropagation(); // Evita que el evento llegue al documento
            });
            
            // Ocultar las instrucciones después de 20 segundos
            setTimeout(() => {
                const infoElement = document.getElementById('info');
                if (infoElement) {
                    infoElement.classList.add('fade-out');
                    
                    // Opcional: remover completamente el elemento después de la transición
                    setTimeout(() => {
                        infoElement.style.display = 'none';
                    }, 2100); // Un poco más que el tiempo de transición
                }
            }, 8000);

            
            // Listener para los botones
            document.getElementById('btnSettings').addEventListener('click', function(event) {
                event.stopPropagation(); // Evita que el clic se propague al documento
                toggleSettingsMenu();
            });           
            document.getElementById('btnTeleport').addEventListener('click', toggleTeleportPanel);
            document.getElementById('btnGoToCoords').addEventListener('click', teleportToCoords);
            document.getElementById('btnPerspective').addEventListener('click', cycleViewMode);
            
            document.getElementById('btnFirstPerson').addEventListener('click', () => setViewMode('firstPerson'));
            document.getElementById('btnThirdPerson').addEventListener('click', () => setViewMode('thirdPerson'));
            document.getElementById('btnBirdEye').addEventListener('click', () => setViewMode('birdEye'));
            
            document.getElementById('connectButton').addEventListener('click', connectToNetwork);
            document.getElementById('usernameInput').value = username;

            // Inicializar coordenadas de teletransporte con posición actual
            updateTeleportCoords();

            // Iniciar animación
            animate();
        }
        
        // Crear avatar para representar al usuario
        function createAvatar() {
            // Cambiar la geometría de cono a esfera
            // El radio de la esfera sería aproximadamente 1 para mantener un tamaño similar
            const geometry = new THREE.SphereGeometry(1, 16, 12); // Esfera con 16 segmentos horizontales y 12 verticales
            
            // Mantener el mismo material con las propiedades existentes
            const material = new THREE.MeshPhongMaterial({ 
                color: 0x4488ff,
                emissive: 0x112244,
                transparent: true,
                opacity: 0.6,
                shininess: 30,
                flatShading: false
            });
            
            avatarObject = new THREE.Mesh(geometry, material);
            avatarObject.position.set(0, 0, 0);
            
            // No necesitamos rotar la esfera en el eje X como hacíamos con el cono
            // ya que una esfera es simétrica en todos los ejes
            // avatarObject.rotation.x = Math.PI / 2; // Esta línea se elimina
            
            avatarObject.castShadow = true;
            scene.add(avatarObject);
            
            // Añadir un pequeño punto de luz al avatar (mantener igual)
            const avatarLight = new THREE.PointLight(0x4488ff, 0.7, 10);
            avatarLight.position.set(0, 0, 0);
            avatarObject.add(avatarLight);
            
            // Actualizar posición inicial de la cámara
            updateCameraPosition();
        }

        // Crear fondo estelar mejorado
        function createStarBackground() {
            // Estrellas lejanas más numerosas
            const starsGeometry = new THREE.BufferGeometry();
            const starsMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.5,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: false
            });
            
            const starsVertices = [];
            for (let i = 0; i < 20000; i++) {
                const x = THREE.MathUtils.randFloatSpread(2000);
                const y = THREE.MathUtils.randFloatSpread(2000);
                const z = THREE.MathUtils.randFloatSpread(2000);
                starsVertices.push(x, y, z);
            }
            
            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
            const stars = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(stars);
            
            // Nebulosas distantes mejoradas
            for (let i = 0; i < 12; i++) {
                createNebula();
            }
        }
        // Almacenar las nebulosas para animación
        const nebulaeObjects = [];
        // Crear una nebulosa con mejor apariencia
        function createNebula() {
            const geometry = new THREE.BufferGeometry();
            const particles = 3000;  // Más partículas para mejor densidad
            
            const positions = new Float32Array(particles * 3);
            const colors = new Float32Array(particles * 3);
            const sizes = new Float32Array(particles);
            
            // Más variedad de colores de nebulosas
            const nebulaTypes = [
                {hue: 0.6, sat: 0.7, name: "Azul"},        // Azul
                {hue: 0.3, sat: 0.5, name: "Verde"},       // Verde
                {hue: 0.05, sat: 0.8, name: "Naranja"},    // Naranja
                {hue: 0.75, sat: 0.6, name: "Púrpura"},    // Púrpura
                {hue: 0.95, sat: 0.7, name: "Rosa"},       // Rosa
                {hue: 0.15, sat: 0.65, name: "Ámbar"},     // Ámbar
                {hue: 0.52, sat: 0.5, name: "Turquesa"}    // Turquesa
            ];
            
            const selectedType = nebulaTypes[Math.floor(Math.random() * nebulaTypes.length)];
            const color = new THREE.Color();
            color.setHSL(selectedType.hue, selectedType.sat, 0.5);
            
            // Posición aleatoria de la nebulosa
            const position = new THREE.Vector3(
                THREE.MathUtils.randFloatSpread(1200),
                THREE.MathUtils.randFloatSpread(1200),
                THREE.MathUtils.randFloatSpread(1200)
            );
            
            // Crear nebulosa más grande
            const nebulaSize = 80 + Math.random() * 150;
            
            // Definir forma más natural
            for (let i = 0; i < particles; i++) {
                // Distribución gaussiana para forma más realista
                let radius = Math.random();
                radius = Math.pow(radius, 1.5) * nebulaSize; // Distribución que favorece el centro
                
                // Forma esférica con aplastamiento
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                // Distorsión para crear forma de nebulosa
                const distortion = 0.6 + Math.random() * 0.8;
                
                // Coordenadas en polares
                const x = radius * Math.sin(phi) * Math.cos(theta) * distortion;
                const y = radius * Math.sin(phi) * Math.sin(theta) * 0.5; // Aplanar en Y
                const z = radius * Math.cos(phi) * distortion;
                
                // Posiciones
                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;
                
                // Color con variación sutil
                const hue = selectedType.hue + (Math.random() - 0.5) * 0.1;
                const c = new THREE.Color().setHSL(hue, selectedType.sat, 0.5 + Math.random() * 0.2);
                colors[i * 3] = c.r;
                colors[i * 3 + 1] = c.g;
                colors[i * 3 + 2] = c.b;
                
                // Tamaños variables
                sizes[i] = 2 + Math.pow(Math.random(), 2) * 12;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            // Material con mejor mezcla
            const material = new THREE.PointsMaterial({
                size: 1.5,
                vertexColors: true,
                transparent: true,
                opacity: 0.25,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true,
                depthWrite: false
            });
            
            const nebula = new THREE.Points(geometry, material);
            
            // Posición global de la nebulosa
            nebula.position.copy(position);
            
            // Parámetros de rotación y movimiento únicos para cada nebulosa
            const nebulaData = {
                object: nebula,
                // Rotación lenta y aleatoria en cada eje
                rotationSpeed: {
                    x: (Math.random() - 0.5) * 0.002,
                    y: (Math.random() - 0.5) * 0.002,
                    z: (Math.random() - 0.5) * 0.002
                },
                // Movimiento en elipse lento
                movementPath: {
                    center: position.clone(),
                    amplitude: {
                        x: 20 + Math.random() * 50,
                        y: 20 + Math.random() * 50,
                        z: 20 + Math.random() * 50
                    },
                    phase: {
                        x: Math.random() * Math.PI * 2,
                        y: Math.random() * Math.PI * 2,
                        z: Math.random() * Math.PI * 2
                    },
                    speed: {
                        x: (Math.random() - 0.5) * 0.005,
                        y: (Math.random() - 0.5) * 0.005,
                        z: (Math.random() - 0.5) * 0.005
                    }
                }
            };
            
            // Añadir a la escena
            scene.add(nebula);
            
            // Almacenar para animación
            nebulaeObjects.push(nebulaData);
        }

        // Modificar la función animate para animar las nebulosas
        function animateNebulae() {
            const time = Date.now() * 0.001; // Tiempo muy lento para movimiento suave
            
            nebulaeObjects.forEach(nebulaData => {
                const { object, rotationSpeed, movementPath } = nebulaData;
                
                // Rotación
                object.rotation.x += rotationSpeed.x;
                object.rotation.y += rotationSpeed.y;
                object.rotation.z += rotationSpeed.z;
                
                // Movimiento en elipse
                object.position.x = movementPath.center.x + 
                    Math.sin(time * movementPath.speed.x + movementPath.phase.x) * movementPath.amplitude.x;
                
                object.position.y = movementPath.center.y + 
                    Math.cos(time * movementPath.speed.y + movementPath.phase.y) * movementPath.amplitude.y;
                
                object.position.z = movementPath.center.z + 
                    Math.sin(time * movementPath.speed.z + movementPath.phase.z) * movementPath.amplitude.z;
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        
        
        
        // 1. INTERCAMBIAR LA ASIGNACIÓN DE TECLAS EN LA FUNCIÓN onKeyDown

        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW':
                    // En tercera persona, W activa moveBackward en lugar de moveForward
                    if (currentViewMode === 'thirdPerson') {
                        moveBackward = true;
                    } else {
                        moveForward = true;
                    }
                    break;
                case 'KeyS':
                    // En tercera persona, S activa moveForward en lugar de moveBackward
                    if (currentViewMode === 'thirdPerson') {
                        moveForward = true;
                    } else {
                        moveBackward = true;
                    }
                    break;
                case 'KeyA':
                    moveLeft = true;
                    break;
                case 'KeyD':
                    moveRight = true;
                    break;
                case 'KeyZ':
                    moveUp = true;
                    break;
                case 'KeyX':
                    moveDown = true;
                    break;
                case 'KeyT':
                    toggleTeleportPanel();
                    break;
                case 'KeyP':
                    cycleViewMode();
                    break;
                case 'KeyQ':
                    rotateCameraLeft = true;
                    break;
                case 'KeyE':
                    rotateCameraRight = true;
                    break;
                case 'Space':
                // Activar modo hipervelocidad
                hyperspaceModeActive = true;
                if (hyperspaceEffect) {
                    hyperspaceEffect.toggleHyperspace(true);
                }
                break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW':
                    // En tercera persona, W controla moveBackward
                    if (currentViewMode === 'thirdPerson') {
                        moveBackward = false;
                    } else {
                        moveForward = false;
                    }
                    break;
                case 'KeyS':
                    // En tercera persona, S controla moveForward
                    if (currentViewMode === 'thirdPerson') {
                        moveForward = false;
                    } else {
                        moveBackward = false;
                    }
                    break;
                case 'KeyA':
                    moveLeft = false;
                    break;
                case 'KeyD':
                    moveRight = false;
                    break;
                case 'KeyZ':
                    moveUp = false;
                    break;
                case 'KeyX':
                    moveDown = false;
                    break;
                case 'KeyQ':
                    rotateCameraLeft = false;
                    break;
                case 'KeyE':
                    rotateCameraRight = false;
                    break;
                case 'Space':
                    // Desactivar modo hipervelocidad
                    hyperspaceModeActive = false;
                    if (hyperspaceEffect) {
                        hyperspaceEffect.toggleHyperspace(false);
                    }
                    break;
            }
        }
        
        // MEJORADO: Control del mouse para mejor navegación
        function onMouseDown(event) {
            // Ignorar clics en el menú de configuración
            if (isClickOnMenu(event)) {
                return;
            }
            
            if (event.button === 0) { // Solo botón izquierdo
                isDragging = true;
                previousMousePosition = {
                    x: event.clientX,
                    y: event.clientY
                };
            }
        }
        
        function isClickOnMenu(event) {
            // Verificar si el clic fue dentro del menú de configuración
            const settingsMenu = document.getElementById('settingsMenu');
            if (settingsMenu.style.display === 'block') {
                const rect = settingsMenu.getBoundingClientRect();
                if (event.clientX >= rect.left && event.clientX <= rect.right &&
                    event.clientY >= rect.top && event.clientY <= rect.bottom) {
                    return true;
                }
            }
            return false;
        }
        
        function onMouseUp(event) {
            isDragging = false;
        }
        
        function onMouseMove(event) {
            // Si estamos arrastrando (clic sostenido), rotar en horizontal
            if (isDragging) {
                const deltaMove = {
                    x: event.clientX - previousMousePosition.x,
                    y: event.clientY - previousMousePosition.y
                };
                
                // Rotación horizontal con arrastre
                yawAngle -= deltaMove.x * mouseSensitivity;
                
                // MODIFICACIÓN: Aplicar también la rotación vertical mientras se arrastra
                // en todas las vistas, no solo en primera persona
                pitchAngle -= deltaMove.y * mouseSensitivity * 0.5;
                pitchAngle = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitchAngle));
                
                // Actualizar la rotación del avatar
                avatarObject.rotation.y = yawAngle;
                
                // Actualizar posición previa
                previousMousePosition = {
                    x: event.clientX,
                    y: event.clientY
                };
            }
            
            // Ya no necesitamos este bloque porque ahora procesamos la mirada vertical
            // mientras se arrastra el mouse en el bloque anterior
            /*
            // Siempre permitir mirar arriba/abajo con movimiento vertical del ratón
            const movementY = event.movementY || 0;
            if (Math.abs(movementY) > 0.5) { // Umbral para evitar movimientos accidentales
                pitchAngle -= movementY * mouseSensitivity * 0.5; // Reducido para suavizar
                pitchAngle = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitchAngle));
            }
            */
            
            // Actualizar la posición de la cámara
            updateCameraPosition();
        }
        
        function onMouseWheel(event) {
            const zoomSpeed = 0.5;
            const delta = Math.sign(event.deltaY) * zoomSpeed;
            
            if (currentViewMode === 'thirdPerson') {
                cameraOffset.z += delta;
                cameraOffset.z = Math.max(5, Math.min(30, cameraOffset.z));
            } else if (currentViewMode === 'birdEye') {
                cameraOffset.y += delta;
                cameraOffset.y = Math.max(10, Math.min(50, cameraOffset.y));
            }
            
            updateCameraPosition();
        }
        
        function updateCameraPosition() {
            switch (currentViewMode) {
                case 'firstPerson':
                    // Primera persona: cámara en la posición del avatar
                    camera.position.copy(avatarObject.position);
                    camera.position.y += 1.7; // Altura de los ojos
                    
                    // Mirar en la dirección que apunta el avatar con inclinación
                    camera.quaternion.setFromEuler(new THREE.Euler(pitchAngle, yawAngle, 0, 'YXZ'));
                    break;
                    
                case 'thirdPerson':
                    // Tercera persona: cámara detrás y arriba del avatar
                    const offsetVector = new THREE.Vector3(
                        -Math.sin(yawAngle) * Math.cos(pitchAngle) * cameraOffset.z,
                        cameraOffset.y + Math.sin(pitchAngle) * cameraOffset.z,
                        -Math.cos(yawAngle) * Math.cos(pitchAngle) * cameraOffset.z
                    );
                    
                    camera.position.copy(avatarObject.position).add(offsetVector);
                    
                    // Mirar hacia el avatar con inclinación
                    cameraTarget.copy(avatarObject.position);
                    cameraTarget.y += 1; // Mirar un poco arriba del centro del avatar
                    camera.lookAt(cameraTarget);
                    break;
                    
                case 'birdEye':
                    // MODIFICADO: Vista de pájaro con soporte para rotación
                    // Posicionar la cámara en alto sobre el avatar pero permitiendo rotación
                    const birdEyeHeight = cameraOffset.y;
                    const birdEyeRadius = cameraOffset.z * 0.5; // Reducido para estar más centrado
                    
                    // Usar la rotación horizontal (yawAngle) para girar alrededor del avatar
                    camera.position.copy(avatarObject.position);
                    camera.position.y += birdEyeHeight;
                    camera.position.x += Math.sin(yawAngle) * birdEyeRadius;
                    camera.position.z += Math.cos(yawAngle) * birdEyeRadius;
                    
                    // Usar pitchAngle para ajustar la inclinación (limitada para vista de pájaro)
                    const birdEyePitch = Math.max(-Math.PI/2, Math.min(-Math.PI/6, pitchAngle));
                    
                    // Calcular el punto de mira con base en la rotación
                    cameraTarget.copy(avatarObject.position);
                    // Ajustar el punto de mira para que mire "adelante" del avatar según la rotación
                    cameraTarget.x += Math.sin(yawAngle) * 5 * Math.sin(birdEyePitch + Math.PI/2);
                    cameraTarget.z += Math.cos(yawAngle) * 5 * Math.sin(birdEyePitch + Math.PI/2);
                    // Ajustar altura del punto de mira según inclinación
                    cameraTarget.y += Math.cos(birdEyePitch + Math.PI/2) * 5;
                    
                    camera.lookAt(cameraTarget);
                    break;
            }
        }


        
        function cycleViewMode() {
            switch (currentViewMode) {
                case 'firstPerson':
                    setViewMode('thirdPerson');
                    break;
                case 'thirdPerson':
                    setViewMode('birdEye');
                    break;
                case 'birdEye':
                    setViewMode('firstPerson');
                    break;
            }
        }
        
        function setViewMode(mode) {
            currentViewMode = mode;
            
            switch (mode) {
                case 'firstPerson':
                    avatarObject.visible = false;
                    // No reset pitchAngle
                    break;
                case 'thirdPerson':
                    avatarObject.visible = true;
                    cameraOffset.set(0, 10, 20);
                    // No reset pitchAngle
                    break;
                case 'birdEye':
                    avatarObject.visible = true;
                    cameraOffset.set(0, 30, 5);
                    // Ajustar pitchAngle para vista de pájaro (mira hacia abajo)
                    pitchAngle = -Math.PI/3; // Aproximadamente -60 grados
            break;
    }
    
    updateCameraPosition();
}

        // CORRECCIÓN EN LA FUNCIÓN ANIMATE PARA ASEGURAR UNA ANIMACIÓN FLUIDA
        function animate() {
            requestAnimationFrame(animate);
            try {
                const speed = 0.2;
                const direction = new THREE.Vector3(-Math.sin(yawAngle), 0, -Math.cos(yawAngle));
                
                // Aplicar efecto de hipervelocidad si está activo
                let currentSpeedFactor = 1.0;
                if (hyperspaceEffect) {
                    // Actualizar el efecto y obtener el factor de velocidad actual
                    currentSpeedFactor = hyperspaceEffect.update(direction);
                }
                
                // Aplicar el factor de velocidad al movimiento
                const adjustedSpeed = speed * currentSpeedFactor;
                const frontVector = direction.clone().normalize().multiplyScalar(adjustedSpeed);
                const rightVector = new THREE.Vector3(frontVector.z, 0, -frontVector.x);

                // Movimiento del avatar según teclas
                if (moveForward) avatarObject.position.add(frontVector);
                if (moveBackward) avatarObject.position.sub(frontVector);
                if (moveLeft) avatarObject.position.sub(rightVector);
                if (moveRight) avatarObject.position.add(rightVector);
                if (moveUp) avatarObject.position.y += adjustedSpeed;
                if (moveDown) avatarObject.position.y -= adjustedSpeed;
                if (rotateCameraLeft) { yawAngle += cameraRotationSpeed; avatarObject.rotation.y = yawAngle; }
                if (rotateCameraRight) { yawAngle -= cameraRotationSpeed; avatarObject.rotation.y = yawAngle; }

                updateCameraPosition();
                updateCoordinatesDisplay();

                // Actualizar galaxia personal
                if (galaxies[username]) {
                    galaxies[username].updatePosition(avatarObject.position.clone());
                    galaxies[username].update();
                }
                
                // Actualizar galaxias de otros jugadores
                for (const playerId in otherPlayers) {
                    if (galaxies[playerId]) {
                        galaxies[playerId].update();
                    }
                }
                
                // Actualizar generador procedural con la posición del avatar
                if (proceduralGenerator) {
                    proceduralGenerator.update(avatarObject.position);
                }

                renderer.render(scene, camera);
            } catch (error) {
                console.error("Error en el ciclo de animación:", error);
            }
        }

        
        function updateCoordinatesDisplay() {
            const x = avatarObject.position.x.toFixed(2);
            const y = avatarObject.position.y.toFixed(2);
            const z = avatarObject.position.z.toFixed(2);
            coordsElement.textContent = `X: ${x}, Y: ${y}, Z: ${z}`;
        }
        
        function updateTeleportCoords() {
            document.getElementById('teleportX').value = avatarObject.position.x.toFixed(2);
            document.getElementById('teleportY').value = avatarObject.position.y.toFixed(2);
            document.getElementById('teleportZ').value = avatarObject.position.z.toFixed(2);
        }
        
        function toggleTeleportPanel() {
            const panel = document.getElementById('teleportPanel');
            if (panel.style.display === 'block') {
                panel.style.display = 'none';
            } else {
                panel.style.display = 'block';
                updateTeleportCoords();
            }
        }
        
        function teleportToCoords() {
            const x = parseFloat(document.getElementById('teleportX').value);
            const y = parseFloat(document.getElementById('teleportY').value);
            const z = parseFloat(document.getElementById('teleportZ').value);
            
            if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
                avatarObject.position.set(x, y, z);
                updateCameraPosition();
                document.getElementById('teleportPanel').style.display = 'none';
            }
        }

        function toggleSettingsMenu() {
            const menu = document.getElementById('settingsMenu');
            if (menu.style.display === 'block') {
                menu.style.display = 'none';
            } else {
                menu.style.display = 'block';
            }
        }

        
        function connectToNetwork() {
            const newUsername = document.getElementById('usernameInput').value.trim();
            if (newUsername && newUsername !== username) {
                if (galaxies[username]) {
                    galaxies[username].dispose();
                    delete galaxies[username];
                }
                
                username = newUsername;
                galaxies[username] = new Galaxy(username, avatarObject.position.clone());
                
                simulateOtherPlayers();
            }
            
            document.getElementById('connectButton').textContent = 'Conectado';
            document.getElementById('connectButton').disabled = true;
        }
        
        function simulateOtherPlayers() {
            for (const playerId in otherPlayers) {
                if (galaxies[playerId]) {
                    galaxies[playerId].dispose();
                    delete galaxies[playerId];
                }
            }
            
            otherPlayers = {};
            
            const playerCount = 2 + Math.floor(Math.random() * 3);
            const playerNames = ["Melodía", "Armonía", "Ritmo", "Sonata", "Sinfónico", "Crescendo"];
            
            for (let i = 0; i < playerCount; i++) {
                const playerId = playerNames[i];
                
                const distance = 50 + Math.random() * 250;
                const angle = Math.random() * Math.PI * 2;
                
                const position = new THREE.Vector3(
                    Math.cos(angle) * distance,
                    (Math.random() - 0.5) * 50,
                    Math.sin(angle) * distance
                );
                
                otherPlayers[playerId] = {
                    position: position,
                    lastUpdate: Date.now()
                };
                
                galaxies[playerId] = new Galaxy(playerId, position);
                
                simulatePlayerNotes(playerId);
            }
            
            updatePlayersList();
        }
        
        function simulatePlayerNotes(playerId) {
            if (!galaxies[playerId]) return;
            
            const note = 48 + Math.floor(Math.random() * 36);
            const velocity = 50 + Math.floor(Math.random() * 77);
            
            galaxies[playerId].addNote(note, velocity);
            
            const nextDelay = 200 + Math.random() * 1800;
            setTimeout(() => {
                simulatePlayerNotes(playerId);
            }, nextDelay);
        }
        
        function updatePlayersList() {
            const container = document.getElementById('playersOnline');
            container.innerHTML = '';
            
            const playerCount = Object.keys(otherPlayers).length + 1;
            container.innerHTML = `<p>Jugadores en línea: ${playerCount}</p>`;
            
            const localItem = document.createElement('div');
            localItem.className = 'midi-device-item active';
            localItem.textContent = `${username} (Tú)`;
            container.appendChild(localItem);
            
            for (const playerId in otherPlayers) {
                const playerItem = document.createElement('div');
                playerItem.className = 'midi-device-item';
                playerItem.textContent = playerId;
                container.appendChild(playerItem);
            }
        }

        function initMIDI() {
            if (navigator.requestMIDIAccess) {
                navigator.requestMIDIAccess({ sysex: false })
                    .then(onMIDISuccess, onMIDIFailure);
            } else {
                midiStatusElement.textContent = 'Tu navegador no soporta Web MIDI API';
            }
        }

        function onMIDISuccess(access) {
            midiAccess = access;
            midiStatusElement.textContent = 'MIDI conectado. Selecciona dispositivos en la configuración.';
            
            midiAccess.addEventListener('statechange', updateDeviceList);
            
            updateDeviceList();
        }

        function onMIDIFailure(error) {
            midiStatusElement.textContent = `Error al acceder a MIDI: ${error}`;
        }

        function updateDeviceList() {
            if (!midiAccess) return;
            
            const container = document.getElementById('midiDevicesContainer');
            container.innerHTML = '';
            
            let deviceCount = 0;
            
            midiAccess.inputs.forEach(input => {
                deviceCount++;
                
                const deviceItem = document.createElement('div');
                deviceItem.className = 'midi-device-item';
                deviceItem.dataset.id = input.id;
                
                const deviceName = document.createElement('span');
                deviceName.textContent = input.name || `Dispositivo ${deviceCount}`;
                deviceItem.appendChild(deviceName);
                
                const toggleBtn = document.createElement('div');
                toggleBtn.className = 'toggle-button';
                if (activeInputs.has(input.id)) {
                    toggleBtn.classList.add('active');
                    deviceItem.classList.add('active');
                }
                deviceItem.appendChild(toggleBtn);
                
                // Mejorado: Manejando separadamente el clic en el dispositivo
                deviceItem.addEventListener('click', function(e) {
                    e.stopPropagation(); // Evita que el clic cierre el menú
                    toggleMIDIInput(input.id);
                    toggleBtn.classList.toggle('active');
                    deviceItem.classList.toggle('active');
                });
                
                container.appendChild(deviceItem);
            });
            
            if (deviceCount === 0) {
                container.innerHTML = '<p>No se encontraron dispositivos MIDI</p>';
            }
            
            midiStatusElement.textContent = `${deviceCount} dispositivo(s) MIDI encontrado(s). ${activeInputs.size} activo(s).`;
        }
        
        function toggleMIDIInput(inputId) {
            const input = midiAccess.inputs.get(inputId);
            
            if (activeInputs.has(inputId)) {
                input.removeEventListener('midimessage', onMIDIMessage);
                activeInputs.delete(inputId);
                console.log(`Dispositivo MIDI desactivado: ${input.name}`);
            } else {
                input.addEventListener('midimessage', onMIDIMessage);
                activeInputs.add(inputId);
                console.log(`Dispositivo MIDI activado: ${input.name}`);
            }
            
            midiStatusElement.textContent = `${midiAccess.inputs.size} dispositivo(s) MIDI encontrado(s). ${activeInputs.size} activo(s).`;
        }

        // Mejora en la función onMIDIMessage para manejar eventos MIDI de manera más robusta
        function onMIDIMessage(event) {
            try {
                const command = event.data[0] >> 4;
                const channel = event.data[0] & 0xf;
                
                const note = event.data[1];
                const velocity = (event.data.length > 2) ? event.data[2] : 0;
                
                if (isNaN(note) || isNaN(velocity)) return;
                
                if (command === 9 && velocity > 0) {
                    // Nota presionada
                    if (galaxies[username]) {
                        galaxies[username].addNote(note, velocity);
                        
                        // Feedback visual mejorado
                        const noteName = getNoteNameFromMIDI(note);
                        midiStatusElement.textContent = `Nota: ${noteName} (${note}), Velocidad: ${velocity}`;
                    }
                }
                else if ((command === 8 || (command === 9 && velocity === 0))) {
                    // Nota liberada
                    if (galaxies[username]) {
                        galaxies[username].removeNote(note);
                    }
                }
            } catch (error) {
                console.error("Error al procesar mensaje MIDI:", error);
            }
        }


         // Agregar un event listener al documento para cerrar el menú al hacer clic fuera
        document.addEventListener('click', function(event) {
            const menu = document.getElementById('settingsMenu');
            const settingsButton = document.getElementById('btnSettings');
            
            // Si el menú está abierto y el clic no fue dentro del menú ni en el botón de configuración
            if (menu.style.display === 'block' && 
                !menu.contains(event.target) && 
                event.target !== settingsButton) {
                menu.style.display = 'none';
            }
        });   

        // Evitar que los clics dentro del menú cierren el menú
        document.getElementById('settingsMenu').addEventListener('click', function(event) {
            event.stopPropagation(); // Evita que el clic se propague al documento
        });

        // Iniciar todo cuando el DOM esté cargado
        document.addEventListener('DOMContentLoaded', function() {
            init();
            initMIDI();
        });
    </script>
</body>
</html>
