<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Musicosmos - Universo Musical Interactivo</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background-color: #000;
            color: white;
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            background-color: rgba(0,0,0,0.5);
            padding: 10px;
            z-index: 100;
            opacity: 1;
            transition: opacity 5s ease-in;
        }
        .fade-out {
            opacity: 0;
        }
        #midiStatus {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            background-color: rgba(0,0,0,0.5);
            padding: 10px;
            z-index: 100;
            border-radius: 5px;
        }
        #coordinates {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background-color: rgba(0,0,0,0.7);
            padding: 10px;
            z-index: 100;
            border-radius: 5px;
            font-family: monospace;
            font-size: 14px;
        }
        #teleportPanel {
            position: absolute;
            bottom: 60px;
            left: 10px;
            color: white;
            background-color: rgba(0,0,0,0.7);
            padding: 15px;
            z-index: 100;
            border-radius: 5px;
            display: none;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(100, 120, 255, 0.3);
            box-shadow: 0 0 15px rgba(100, 120, 255, 0.3);
        }
        #teleportPanel input {
            width: 60px;
            background-color: rgba(30,30,40,0.8);
            color: white;
            border: 1px solid #557;
            border-radius: 3px;
            padding: 5px;
            margin: 0 5px;
            font-family: monospace;
        }
        #teleportPanel button {
            background-color: #4466dd;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 6px 12px;
            cursor: pointer;
            margin-left: 10px;
        }
        #teleportPanel button:hover {
            background-color: #5577ee;
        }
        canvas {
            display: block;
        }
        .btn-settings {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            background-color: rgba(50,50,70,0.6);
            color: white;
            border: none;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            box-shadow: 0 0 15px rgba(100,100,255,0.5);
            z-index: 200;
        }
        .btn-settings:hover {
            background-color: rgba(70,70,100,0.8);
            transform: scale(1.1);
        }
        .btn-teleport {
            position: absolute;
            bottom: 20px;
            left: 10px;
            background-color: rgba(50,50,70,0.6);
            color: white;
            border: none;
            border-radius: 5px;
            padding: 10px 15px;
            font-size: 14px;
            cursor: pointer;
            transition: background-color 0.3s;
            box-shadow: 0 0 10px rgba(100,100,255,0.5);
            z-index: 200;
        }
        .btn-teleport:hover {
            background-color: rgba(70,70,100,0.8);
        }
        .btn-perspective {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background-color: rgba(50,50,70,0.6);
            color: white;
            border: none;
            border-radius: 5px;
            padding: 10px 15px;
            font-size: 14px;
            cursor: pointer;
            transition: background-color 0.3s;
            box-shadow: 0 0 10px rgba(100,100,255,0.5);
            z-index: 200;
        }
        .btn-perspective:hover {
            background-color: rgba(70,70,100,0.8);
        }
        #settingsMenu {
            position: absolute;
            top: 80px;
            right: 20px;
            width: 300px;
            max-height: 80vh;
            overflow-y: auto;
            background-color: rgba(30,30,50,0.9);
            color: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 0 20px rgba(0,0,255,0.3);
            z-index: 200;
            display: none;
            backdrop-filter: blur(5px);
        }
        #settingsMenu h3 {
            margin-top: 0;
            color: #aaf;
            border-bottom: 1px solid #557;
            padding-bottom: 10px;
        }
        #viewControls {
            position: absolute;
            right: 20px;
            bottom: 70px;
            color: white;
            background-color: rgba(0,0,0,0.5);
            padding: 10px;
            z-index: 100;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        #viewControls button {
            background-color: rgba(50,50,70,0.6);
            color: white;
            border: none;
            border-radius: 5px;
            padding: 5px 10px;
            font-size: 12px;
            cursor: pointer;
        }
        #viewControls button:hover {
            background-color: rgba(70,70,100,0.8);
        }
        .midi-device-item {
            margin-bottom: 10px;
            padding: 8px;
            background-color: rgba(50,50,80,0.5);
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .midi-device-item.active {
            background-color: rgba(80,80,180,0.5);
            border-left: 3px solid #88f;
        }
        .toggle-button {
            width: 40px;
            height: 20px;
            background-color: #444;
            border-radius: 10px;
            position: relative;
            cursor: pointer;
        }
        .toggle-button.active {
            background-color: #55f;
        }
        .toggle-button::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            background-color: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: transform 0.3s;
        }
        .toggle-button.active::after {
            transform: translateX(20px);
        }
        .network-status {
            margin-top: 20px;
            padding-top: 10px;
            border-top: 1px solid #557;
        }
        #usernameInput {
            width: 100%;
            padding: 8px;
            margin: 10px 0;
            background-color: rgba(40,40,60,0.9);
            color: white;
            border: 1px solid #557;
            border-radius: 5px;
        }
        #connectButton {
            padding: 8px 16px;
            background-color: #4466dd;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        #connectButton:hover {
            background-color: #5577ee;
        }
    </style>
</head>
<body>
    <div id="info">
        <h1>Musicosmos</h1>
        <p>Conecta un dispositivo MIDI y toca para crear galaxias musicales.</p>
        <p>Usa las teclas W, A, S, D para moverte, ratón para navegar en todas direcciones.</p>
    </div>
    
    <div id="midiStatus">Esperando conexión MIDI...</div>
    <div id="coordinates">X: 0.00, Y: 0.00, Z: 0.00</div>
    
    <button class="btn-teleport" id="btnTeleport">Teletransporte</button>
    <button class="btn-perspective" id="btnPerspective">Cambiar Vista</button>
    
    <div id="teleportPanel">
        <div>X: <input type="number" id="teleportX" step="0.1"></div>
        <div>Y: <input type="number" id="teleportY" step="0.1"></div>
        <div>Z: <input type="number" id="teleportZ" step="0.1"></div>
        <button id="btnGoToCoords">Ir a Coordenadas</button>
    </div>
    
    <div id="viewControls">
        <button id="btnFirstPerson">Vista en Primera Persona</button>
        <button id="btnThirdPerson">Vista en Tercera Persona</button>
        <button id="btnBirdEye">Vista de Pájaro</button>
    </div>
    
    <button class="btn-settings" id="btnSettings">⚙️</button>
    
    <div id="settingsMenu">
        <h3>Configuración</h3>
        <div>
            <h4>Dispositivos MIDI</h4>
            <div id="midiDevicesContainer">
                <p>No se encontraron dispositivos MIDI</p>
            </div>
        </div>
        
        <div class="network-status">
            <h4>Multijugador</h4>
            <input type="text" id="usernameInput" placeholder="Tu nombre en el cosmos" maxlength="20">
            <button id="connectButton">Conectar</button>
            <div id="playersOnline"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Variables principales
        let scene, camera, renderer;
        let galaxies = {};
        let particles = [];  // Para mezcla de colores global
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let moveUp = false;
        let moveDown = false;
        let pitchAngle = 0;
        let yawAngle = 0;
        let gridHelper;
        
        // Objetos para la cámara
        let avatarObject;
        let cameraTarget = new THREE.Vector3();
        let cameraOffset = new THREE.Vector3(0, 10, 20);
        let currentViewMode = 'thirdPerson';
        
        // Variables de control del mouse
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let mouseSensitivity = 0.003;
        
        // Variables MIDI
        let midiAccess = null;
        let activeInputs = new Set();
        let midiStatusElement = document.getElementById('midiStatus');
        let coordsElement = document.getElementById('coordinates');
        
        // Variables de red
        let username = "Explorador" + Math.floor(Math.random() * 1000);
        let otherPlayers = {};
        
        // Configuración física mejorada de galaxias
        const GALAXY_CONFIG = {
            particleCount: 8000,        // Más partículas para mejor efecto
            maxSize: 80,               // Mayor tamaño máximo
            coreIntensity: 1.5,        // Más brillo en el núcleo
            expansionRate: 0.025,      // Velocidad de expansión
            rotationSpeed: 0.0008,     // Rotación
            fadeRate: 0.002,           // Desvanecimiento
            spiralFactor: 3.5,         // Factor espiral más pronunciado
            armCount: 5,               // Brazos
            armWidth: 0.4,             // Ancho de brazos
            viewingDistance: 30,       // Distancia de visualización
            interactionDistance: 2.0,  // Distancia para mezcla de colores entre partículas
            sphereQuality: 8,          // Calidad de las esferas (segmentos)
            mixingIntensity: 0.3       // Intensidad de la mezcla de colores (0-1)
        };
        
        // Clase para partícula individual
        class GalaxyParticle {
            constructor(note, velocity, position, radius = 0, ownerId) {
                this.note = note;
                this.velocity = velocity;
                this.initialPosition = position.clone();
                this.position = position.clone();
                this.originalColor = this.noteToColor(note);
                this.color = this.originalColor.clone();
                this.size = 0.05 + (velocity / 127) * 0.15;
                this.alpha = 1.0;
                this.birthTime = Date.now();
                this.lifespan = 5000 + (velocity * 100);  // Mayor duración
                this.ownerId = ownerId;  // Identificador del creador de la partícula
                
                // Parámetros físicos
                this.spiralOffset = Math.random() * Math.PI * 2;
                this.orbitalDistance = radius > 0 ? radius : 0.1 + Math.random() * 7;
                this.height = (Math.random() - 0.5) * this.orbitalDistance * 0.2;
                this.orbitalPlane = new THREE.Vector3(
                    Math.random() - 0.5,
                    (Math.random() - 0.5) * 0.25,
                    Math.random() - 0.5
                ).normalize();
                
                this.armIndex = Math.floor(Math.random() * GALAXY_CONFIG.armCount);
                this.rotationSpeed = 0.005 / Math.sqrt(Math.max(0.1, this.orbitalDistance));
                
                // Crear geometría esférica real
                this.createSphereGeometry();
            }
            
            createSphereGeometry() {
                // Crear geometría esférica
                const geometry = new THREE.SphereGeometry(
                    this.size, 
                    GALAXY_CONFIG.sphereQuality, 
                    GALAXY_CONFIG.sphereQuality
                );
                
                // Material con iluminación suave
                const material = new THREE.MeshPhongMaterial({
                    color: this.color,
                    emissive: this.color.clone().multiplyScalar(0.5),
                    transparent: true,
                    opacity: 1.0,
                    shininess: 50,
                    flatShading: false
                });
                
                // Crear la malla
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(this.position);
                
                // Añadir a la escena
                scene.add(this.mesh);
                
                // Añadir a la lista global de partículas para la detección de colisiones
                particles.push(this);
            }
            
            update() {
                const age = Date.now() - this.birthTime;
                const lifePercent = Math.min(age / this.lifespan, 1);
                
                // Actualizar posición según patrones galácticos
                const expansionProgress = Math.min(age / 2000, 1);
                const armAngle = (this.armIndex / GALAXY_CONFIG.armCount) * Math.PI * 2;
                const spiralTightness = GALAXY_CONFIG.spiralFactor * Math.log(1 + this.orbitalDistance);
                const spiralAngle = this.spiralOffset + (spiralTightness * Math.PI * 2);
                const finalAngle = armAngle + spiralAngle;
                const orbitSize = this.orbitalDistance * expansionProgress;
                
                // Añadir variación
                const armWidthFactor = 1 - Math.exp(-orbitSize / 2);
                const dispersion = GALAXY_CONFIG.armWidth * armWidthFactor;
                const deviation = (Math.random() - 0.5) * dispersion;
                
                // Calcular posición
                const x = Math.cos(finalAngle + deviation) * orbitSize;
                const z = Math.sin(finalAngle + deviation) * orbitSize;
                const y = this.height * expansionProgress;
                
                this.position.set(
                    this.initialPosition.x + x,
                    this.initialPosition.y + y,
                    this.initialPosition.z + z
                );
                
                // Actualizar mesh
                if (this.mesh) {
                    this.mesh.position.copy(this.position);
                    
                    // Desvanecer gradualmente
                    if (lifePercent > 0.7) {
                        this.alpha = 1.0 - ((lifePercent - 0.7) / 0.3);
                        this.mesh.material.opacity = this.alpha;
                    }
                    
                    // Mezcla de colores con otras partículas
                    this.interactWithNearbyParticles();
                }
                
                // Devolver false cuando la partícula debe ser eliminada
                if (lifePercent >= 1) {
                    this.dispose();
                    return false;
                }
                
                return true;
            }
            
            interactWithNearbyParticles() {
                // Comprobar la distancia con otras partículas para mezcla de colores
                for (let i = 0; i < particles.length; i++) {
                    const otherParticle = particles[i];
                    
                    // No mezclar con uno mismo o partículas del mismo creador
                    if (otherParticle === this || otherParticle.ownerId === this.ownerId) {
                        continue;
                    }
                    
                    // Calcular distancia
                    const distance = this.position.distanceTo(otherParticle.position);
                    
                    // Si están lo suficientemente cerca, mezclar colores
                    if (distance < GALAXY_CONFIG.interactionDistance) {
                        const mixFactor = 1 - (distance / GALAXY_CONFIG.interactionDistance);
                        this.mixColor(otherParticle.color, mixFactor * GALAXY_CONFIG.mixingIntensity);
                    }
                }
            }
            
            mixColor(otherColor, factor) {
                // Mezclar color actual con otherColor según el factor
                const newR = this.color.r * (1 - factor) + otherColor.r * factor;
                const newG = this.color.g * (1 - factor) + otherColor.g * factor;
                const newB = this.color.b * (1 - factor) + otherColor.b * factor;
                
                // Actualizar color
                this.color.setRGB(newR, newG, newB);
                
                // Actualizar material si existe
                if (this.mesh && this.mesh.material) {
                    this.mesh.material.color.copy(this.color);
                    this.mesh.material.emissive.copy(this.color).multiplyScalar(0.5);
                    this.mesh.material.needsUpdate = true;
                }
            }
            
            dispose() {
                // Eliminar de la escena
                if (this.mesh) {
                    scene.remove(this.mesh);
                    this.mesh.geometry.dispose();
                    this.mesh.material.dispose();
                    this.mesh = null;
                }
                
                // Eliminar de la lista global de partículas
                const index = particles.indexOf(this);
                if (index > -1) {
                    particles.splice(index, 1);
                }
            }
            
            noteToColor(note) {
                // Colores basados en el círculo cromático musical
                const hue = ((127 - note) % 48) / 48;
                const lightness = 0.5 + ((Math.floor(note / 12) % 5) / 12);
                return new THREE.Color().setHSL(hue, 0.8, lightness);
            }
        }
        
        // Clase Galaxy para manejar conjuntos de partículas
        class Galaxy {
            constructor(id, initialPosition) {
                this.id = id;
                this.position = initialPosition.clone();
                this.particles = [];
                this.activeNotes = new Map();
                this.lastNoteTime = Date.now();
                this.energy = 0;
                this.rotation = 0;
                this.creationTime = Date.now();
                
                // Crear núcleo brillante
                this.createGalaxyCore();
            }
            
            createGalaxyCore() {
                // Luz central con mayor alcance
                this.coreLight = new THREE.PointLight(0x6688ff, 1.5, 20);
                this.coreLight.position.copy(this.position);
                scene.add(this.coreLight);
                
                // Esfera brillante para el núcleo con mejor calidad
                const coreGeometry = new THREE.SphereGeometry(0.7, 24, 24);
                const coreMaterial = new THREE.MeshPhongMaterial({
                    color: 0xaaccff,
                    emissive: 0x4466aa,
                    transparent: true,
                    opacity: 0.8,
                    shininess: 80,
                    specular: 0xffffff
                });
                
                this.coreObject = new THREE.Mesh(coreGeometry, coreMaterial);
                this.coreObject.position.copy(this.position);
                scene.add(this.coreObject);
            }
            
            addNote(note, velocity) {
                // Registrar nota activa
                this.activeNotes.set(note, {
                    velocity: velocity,
                    time: Date.now()
                });
                
                // Aumentar energía de la galaxia
                this.energy = Math.min(1.0, this.energy + (velocity / 127) * 0.2);
                this.lastNoteTime = Date.now();
                
                // Ajustar brillo del núcleo según energía
                if (this.coreLight) {
                    this.coreLight.intensity = 1.5 + this.energy * 4.0;
                    this.coreObject.scale.set(
                        1.0 + this.energy * 2.0,
                        1.0 + this.energy * 2.0,
                        1.0 + this.energy * 2.0
                    );
                }
                
                // Crear más partículas para notas fuertes
                const particleCount = Math.floor(15 + (velocity / 127) * 40);
                
                // Posición para las nuevas partículas
                const direction = new THREE.Vector3();
                avatarObject.getWorldDirection(direction);
                
                const viewPosition = new THREE.Vector3();
                if (this.id === username) {
                    // Para nuestra propia galaxia, crear las partículas frente a nosotros
                    viewPosition.copy(avatarObject.position.clone());
                    const viewVector = direction.clone().multiplyScalar(GALAXY_CONFIG.viewingDistance);
                    viewPosition.add(viewVector);
                } else {
                    viewPosition.copy(this.position);
                }
                
                // Crear partículas con distribución natural
                for (let i = 0; i < particleCount; i++) {
                    // Distribución de densidad que favorece ciertas distancias
                    let radius = (Math.random() * 0.7 + 0.3) * 6;
                    
                    // Especializaciones para tipos de estrellas
                    if (Math.random() < 0.3) {
                        // Estrellas del núcleo
                        radius *= 0.3; 
                    }
                    if (Math.random() < 0.1) {
                        // Estrellas del halo
                        radius *= 1.8;
                    }
                    
                    // Variación en posición inicial
                    const jitter = new THREE.Vector3(
                        (Math.random() - 0.5) * 0.8,
                        (Math.random() - 0.5) * 0.8,
                        (Math.random() - 0.5) * 0.8
                    );
                    
                    // Crear partícula con propietario para tracking
                    const particle = new GalaxyParticle(
                        note, 
                        velocity, 
                        viewPosition.clone().add(jitter),
                        radius,
                        this.id  // ID del propietario
                    );
                    
                    // Variación en tamaño basada en tipo estelar
                    if (Math.random() < 0.05) {
                        // Gigantes
                        particle.size *= 2.0;
                        if (particle.mesh) {
                            particle.mesh.scale.set(2.0, 2.0, 2.0);
                        }
                    }
                    if (Math.random() < 0.01) {
                        // Supernovas
                        particle.size *= 3.0;
                        particle.color.setRGB(1.0, 0.8, 0.6);
                        if (particle.mesh) {
                            particle.mesh.scale.set(3.0, 3.0, 3.0);
                            particle.mesh.material.color.copy(particle.color);
                            particle.mesh.material.emissive.copy(particle.color).multiplyScalar(0.7);
                        }
                    }
                    
                    this.particles.push(particle);
                }
            }
            
            removeNote(note) {
                this.activeNotes.delete(note);
            }
            
            update() {
                // Actualizar energía
                const timeSinceLastNote = Date.now() - this.lastNoteTime;
                if (timeSinceLastNote > 2000) {
                    this.energy = Math.max(0, this.energy - 0.01);
                    
                    // Ajustar brillo del núcleo según energía
                    if (this.coreLight) {
                        this.coreLight.intensity = 1.5 + this.energy * 4.0;
                        this.coreObject.scale.set(
                            1.0 + this.energy * 2.0,
                            1.0 + this.energy * 2.0,
                            1.0 + this.energy * 2.0
                        );
                    }
                }
                
                // Actualizar rotación
                this.rotation += GALAXY_CONFIG.rotationSpeed * (1.0 + this.energy);
                
                // Actualizar partículas individuales y filtrar las que terminaron
                this.particles = this.particles.filter(particle => particle.update());
                
                // Actualizar posición del núcleo
                if (this.coreLight) {
                    this.coreLight.position.copy(this.position);
                    this.coreObject.position.copy(this.position);
                    
                    // Rotación suave del núcleo
                    this.coreObject.rotation.y += 0.01;
                }
            }
            
            updatePosition(newPos) {
                this.position.copy(newPos);
            }
            
            dispose() {
                // Eliminar todas las partículas
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    this.particles[i].dispose();
                }
                this.particles = [];
                
                // Eliminar núcleo
                if (this.coreLight) {
                    scene.remove(this.coreLight);
                    scene.remove(this.coreObject);
                    this.coreObject.geometry.dispose();
                    this.coreObject.material.dispose();
                }
            }
        }

        function init() {
            // Crear escena
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000011);
            scene.fog = new THREE.FogExp2(0x000011, 0.0004); // Niebla más sutil
            
            // Añadir efecto de bloom para mejor apariencia
            const renderScene = new THREE.Scene();
            
            // Configurar cámara
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 20);
            
            // Crear renderer
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limitar para mejor rendimiento
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // Iluminación ambiental
            const ambientLight = new THREE.AmbientLight(0x101020);
            scene.add(ambientLight);

            // Luz direccional principal
            const directionalLight = new THREE.DirectionalLight(0x3333ff, 0.4);
            directionalLight.position.set(1, 1, 1);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Luz complementaria
            const backLight = new THREE.DirectionalLight(0x5544ee, 0.2);
            backLight.position.set(-1, -1, -1);
            scene.add(backLight);

            // Crear plano cartesiano con cuadrícula
            gridHelper = new THREE.GridHelper(1000, 100, 0x333366, 0x222244);
            scene.add(gridHelper);

            // Crear avatar para representar al usuario
            createAvatar();
            
            // Crear fondo estelar
            createStarBackground();
            
            // Crear galaxia personal
            galaxies[username] = new Galaxy(username, avatarObject.position.clone());

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            
            // Mejorado: Ahora usamos mousedown en el documento, pero verificamos si fue en el menú
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('wheel', onMouseWheel);
            
            // Prevenir que los clics en el menú cierren el arrastre
            document.getElementById('settingsMenu').addEventListener('mousedown', function(event) {
                event.stopPropagation(); // Evita que el evento llegue al documento
            });
            
            // Ocultar las instrucciones después de 20 segundos
            setTimeout(() => {
                document.getElementById('info').classList.add('fade-out');
            }, 20000);
            
            // Listener para los botones
            document.getElementById('btnSettings').addEventListener('click', toggleSettingsMenu);
            document.getElementById('btnTeleport').addEventListener('click', toggleTeleportPanel);
            document.getElementById('btnGoToCoords').addEventListener('click', teleportToCoords);
            document.getElementById('btnPerspective').addEventListener('click', cycleViewMode);
            
            document.getElementById('btnFirstPerson').addEventListener('click', () => setViewMode('firstPerson'));
            document.getElementById('btnThirdPerson').addEventListener('click', () => setViewMode('thirdPerson'));
            document.getElementById('btnBirdEye').addEventListener('click', () => setViewMode('birdEye'));
            
            document.getElementById('connectButton').addEventListener('click', connectToNetwork);
            document.getElementById('usernameInput').value = username;

            // Inicializar coordenadas de teletransporte con posición actual
            updateTeleportCoords();

            // Iniciar animación
            animate();
        }
        
        // Crear avatar para representar al usuario
        function createAvatar() {
            // Geometría más detallada
            const geometry = new THREE.ConeGeometry(1, 2, 8);
            const material = new THREE.MeshPhongMaterial({ 
                color: 0x4488ff,
                emissive: 0x112244,
                transparent: true,
                opacity: 0.6,
                shininess: 30,
                flatShading: false
            });
            
            avatarObject = new THREE.Mesh(geometry, material);
            avatarObject.position.set(0, 0, 0);
            avatarObject.rotation.x = Math.PI / 2; // Apuntar hacia adelante
            avatarObject.castShadow = true;
            scene.add(avatarObject);
            
            // Añadir un pequeño punto de luz al avatar
            const avatarLight = new THREE.PointLight(0x4488ff, 0.7, 10);
            avatarLight.position.set(0, 0, 0);
            avatarObject.add(avatarLight);
            
            // Actualizar posición inicial de la cámara
            updateCameraPosition();
        }

        // Crear fondo estelar mejorado
        function createStarBackground() {
            // Estrellas lejanas más numerosas
            const starsGeometry = new THREE.BufferGeometry();
            const starsMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.5,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: false
            });
            
            const starsVertices = [];
            for (let i = 0; i < 20000; i++) {
                const x = THREE.MathUtils.randFloatSpread(2000);
                const y = THREE.MathUtils.randFloatSpread(2000);
                const z = THREE.MathUtils.randFloatSpread(2000);
                starsVertices.push(x, y, z);
            }
            
            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
            const stars = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(stars);
            
            // Nebulosas distantes mejoradas
            for (let i = 0; i < 12; i++) {
                createNebula();
            }
        }
        
        // Crear una nebulosa con mejor apariencia
        function createNebula() {
            const geometry = new THREE.BufferGeometry();
            const particles = 3000;  // Más partículas para mejor densidad
            
            const positions = new Float32Array(particles * 3);
            const colors = new Float32Array(particles * 3);
            const sizes = new Float32Array(particles);
            
            // Más variedad de colores de nebulosas
            const nebulaTypes = [
                {hue: 0.6, sat: 0.7, name: "Azul"},        // Azul
                {hue: 0.3, sat: 0.5, name: "Verde"},       // Verde
                {hue: 0.05, sat: 0.8, name: "Naranja"},    // Naranja
                {hue: 0.75, sat: 0.6, name: "Púrpura"},    // Púrpura
                {hue: 0.95, sat: 0.7, name: "Rosa"},       // Rosa
                {hue: 0.15, sat: 0.65, name: "Ámbar"},     // Ámbar
                {hue: 0.52, sat: 0.5, name: "Turquesa"}    // Turquesa
            ];
            
            const selectedType = nebulaTypes[Math.floor(Math.random() * nebulaTypes.length)];
            const color = new THREE.Color();
            color.setHSL(selectedType.hue, selectedType.sat, 0.5);
            
            // Posición aleatoria de la nebulosa
            const position = new THREE.Vector3(
                THREE.MathUtils.randFloatSpread(1200),
                THREE.MathUtils.randFloatSpread(1200),
                THREE.MathUtils.randFloatSpread(1200)
            );
            
            // Crear nebulosa más grande
            const nebulaSize = 80 + Math.random() * 150;
            
            // Definir forma más natural
            for (let i = 0; i < particles; i++) {
                // Distribución gaussiana para forma más realista
                let radius = Math.random();
                radius = Math.pow(radius, 1.5) * nebulaSize; // Distribución que favorece el centro
                
                // Forma esférica con aplastamiento
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                // Distorsión para crear forma de nebulosa
                const distortion = 0.6 + Math.random() * 0.8;
                
                // Coordenadas en polares
                const x = radius * Math.sin(phi) * Math.cos(theta) * distortion;
                const y = radius * Math.sin(phi) * Math.sin(theta) * 0.5; // Aplanar en Y
                const z = radius * Math.cos(phi) * distortion;
                
                // Posiciones
                positions[i * 3] = position.x + x;
                positions[i * 3 + 1] = position.y + y;
                positions[i * 3 + 2] = position.z + z;
                
                // Color con variación sutil
                const hue = selectedType.hue + (Math.random() - 0.5) * 0.1;
                const c = new THREE.Color().setHSL(hue, selectedType.sat, 0.5 + Math.random() * 0.2);
                colors[i * 3] = c.r;
                colors[i * 3 + 1] = c.g;
                colors[i * 3 + 2] = c.b;
                
                // Tamaños variables
                sizes[i] = 2 + Math.pow(Math.random(), 2) * 12;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            // Material con mejor mezcla
            const material = new THREE.PointsMaterial({
                size: 1.5,
                vertexColors: true,
                transparent: true,
                opacity: 0.25,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true,
                depthWrite: false
            });
            
            const nebula = new THREE.Points(geometry, material);
            scene.add(nebula);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW':
                    moveForward = true;
                    break;
                case 'KeyS':
                    moveBackward = true;
                    break;
                case 'KeyA':
                    moveLeft = true;
                    break;
                case 'KeyD':
                    moveRight = true;
                    break;
                case 'KeyZ':
                    moveUp = true;
                    break;
                case 'KeyX':
                    moveDown = true;
                    break;
                case 'KeyT':
                    toggleTeleportPanel();
                    break;
                case 'KeyP':
                    cycleViewMode();
                    break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW':
                    moveForward = false;
                    break;
                case 'KeyS':
                    moveBackward = false;
                    break;
                case 'KeyA':
                    moveLeft = false;
                    break;
                case 'KeyD':
                    moveRight = false;
                    break;
                case 'KeyZ':
                    moveUp = false;
                    break;
                case 'KeyX':
                    moveDown = false;
                    break;
            }
        }
        
        // MEJORADO: Control del mouse para mejor navegación
        function onMouseDown(event) {
            // Ignorar clics en el menú de configuración
            if (isClickOnMenu(event)) {
                return;
            }
            
            if (event.button === 0) { // Solo botón izquierdo
                isDragging = true;
                previousMousePosition = {
                    x: event.clientX,
                    y: event.clientY
                };
            }
        }
        
        function isClickOnMenu(event) {
            // Verificar si el clic fue dentro del menú de configuración
            const settingsMenu = document.getElementById('settingsMenu');
            if (settingsMenu.style.display === 'block') {
                const rect = settingsMenu.getBoundingClientRect();
                if (event.clientX >= rect.left && event.clientX <= rect.right &&
                    event.clientY >= rect.top && event.clientY <= rect.bottom) {
                    return true;
                }
            }
            return false;
        }
        
        function onMouseUp(event) {
            isDragging = false;
        }
        
        function onMouseMove(event) {
            // Si estamos arrastrando (clic sostenido), rotar en horizontal
            if (isDragging) {
                const deltaMove = {
                    x: event.clientX - previousMousePosition.x,
                    y: event.clientY - previousMousePosition.y
                };
                
                // Rotación horizontal con arrastre
                yawAngle -= deltaMove.x * mouseSensitivity;
                
                // Actualizar la rotación del avatar
                avatarObject.rotation.y = yawAngle;
                
                // Actualizar posición previa
                previousMousePosition = {
                    x: event.clientX,
                    y: event.clientY
                };
            }
            
            // Siempre permitir mirar arriba/abajo con movimiento vertical del ratón
            const movementY = event.movementY || 0;
            if (Math.abs(movementY) > 0.5) { // Umbral para evitar movimientos accidentales
                pitchAngle -= movementY * mouseSensitivity * 0.5; // Reducido para suavizar
                pitchAngle = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitchAngle));
            }
            
            // Actualizar la posición de la cámara
            updateCameraPosition();
        }
        
        function onMouseWheel(event) {
            const zoomSpeed = 0.5;
            const delta = Math.sign(event.deltaY) * zoomSpeed;
            
            if (currentViewMode === 'thirdPerson') {
                cameraOffset.z += delta;
                cameraOffset.z = Math.max(5, Math.min(30, cameraOffset.z));
            } else if (currentViewMode === 'birdEye') {
                cameraOffset.y += delta;
                cameraOffset.y = Math.max(10, Math.min(50, cameraOffset.y));
            }
            
            updateCameraPosition();
        }
        
        function updateCameraPosition() {
            switch (currentViewMode) {
                case 'firstPerson':
                    // Primera persona: cámara en la posición del avatar
                    camera.position.copy(avatarObject.position);
                    camera.position.y += 1.7; // Altura de los ojos
                    
                    // Mirar en la dirección que apunta el avatar con inclinación
                    camera.quaternion.setFromEuler(new THREE.Euler(pitchAngle, yawAngle, 0, 'YXZ'));
                    break;
                    
                case 'thirdPerson':
                    // Tercera persona: cámara detrás y arriba del avatar
                    const offsetVector = new THREE.Vector3(
                        -Math.sin(yawAngle) * cameraOffset.z,
                        cameraOffset.y,
                        -Math.cos(yawAngle) * cameraOffset.z
                    );
                    
                    camera.position.copy(avatarObject.position).add(offsetVector);
                    
                    // Mirar hacia el avatar con inclinación
                    cameraTarget.copy(avatarObject.position);
                    cameraTarget.y += 1; // Mirar un poco arriba del centro del avatar
                    camera.lookAt(cameraTarget);
                    break;
                    
                case 'birdEye':
                    // Vista de pájaro: cámara muy arriba mirando hacia abajo
                    camera.position.copy(avatarObject.position);
                    camera.position.y += cameraOffset.y;
                    camera.position.z += cameraOffset.z * 0.3;
                    
                    // Mirar hacia abajo al avatar
                    cameraTarget.copy(avatarObject.position);
                    camera.lookAt(cameraTarget);
                    break;
            }
        }
        
        function cycleViewMode() {
            switch (currentViewMode) {
                case 'firstPerson':
                    setViewMode('thirdPerson');
                    break;
                case 'thirdPerson':
                    setViewMode('birdEye');
                    break;
                case 'birdEye':
                    setViewMode('firstPerson');
                    break;
            }
        }
        
        function setViewMode(mode) {
            currentViewMode = mode;
            
            switch (mode) {
                case 'firstPerson':
                    avatarObject.visible = false;
                    break;
                case 'thirdPerson':
                    avatarObject.visible = true;
                    cameraOffset.set(0, 10, 20);
                    break;
                case 'birdEye':
                    avatarObject.visible = true;
                    cameraOffset.set(0, 30, 5);
                    break;
            }
            
            updateCameraPosition();
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const speed = 0.2;
            const direction = new THREE.Vector3();
            
            direction.set(
                -Math.sin(yawAngle),
                0,
                -Math.cos(yawAngle)
            );
            
            const frontVector = direction.clone().normalize().multiplyScalar(speed);
            const rightVector = new THREE.Vector3(frontVector.z, 0, -frontVector.x);
            
            // Aplicar movimiento basado en las teclas presionadas
            if (moveForward) {
                avatarObject.position.add(frontVector);
            }
            if (moveBackward) {
                avatarObject.position.sub(frontVector);
            }
            if (moveLeft) {
                avatarObject.position.sub(rightVector);
            }
            if (moveRight) {
                avatarObject.position.add(rightVector);
            }
            if (moveUp) {
                avatarObject.position.y += speed;
            }
            if (moveDown) {
                avatarObject.position.y -= speed;
            }
            
            // Actualizar posición de la cámara
            updateCameraPosition();
            
            // Actualizar visualización de coordenadas
            updateCoordinatesDisplay();
            
            // Actualizar galaxia personal
            if (galaxies[username]) {
                galaxies[username].updatePosition(avatarObject.position.clone());
                galaxies[username].update();
            }
            
            // Actualizar otras galaxias
            for (const playerId in otherPlayers) {
                if (galaxies[playerId]) {
                    galaxies[playerId].update();
                }
            }
            
            // Renderizar escena
            renderer.render(scene, camera);
        }
        
        function updateCoordinatesDisplay() {
            const x = avatarObject.position.x.toFixed(2);
            const y = avatarObject.position.y.toFixed(2);
            const z = avatarObject.position.z.toFixed(2);
            coordsElement.textContent = `X: ${x}, Y: ${y}, Z: ${z}`;
        }
        
        function updateTeleportCoords() {
            document.getElementById('teleportX').value = avatarObject.position.x.toFixed(2);
            document.getElementById('teleportY').value = avatarObject.position.y.toFixed(2);
            document.getElementById('teleportZ').value = avatarObject.position.z.toFixed(2);
        }
        
        function toggleTeleportPanel() {
            const panel = document.getElementById('teleportPanel');
            if (panel.style.display === 'block') {
                panel.style.display = 'none';
            } else {
                panel.style.display = 'block';
                updateTeleportCoords();
            }
        }
        
        function teleportToCoords() {
            const x = parseFloat(document.getElementById('teleportX').value);
            const y = parseFloat(document.getElementById('teleportY').value);
            const z = parseFloat(document.getElementById('teleportZ').value);
            
            if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
                avatarObject.position.set(x, y, z);
                updateCameraPosition();
                document.getElementById('teleportPanel').style.display = 'none';
            }
        }

        function toggleSettingsMenu() {
            const menu = document.getElementById('settingsMenu');
            if (menu.style.display === 'block') {
                menu.style.display = 'none';
            } else {
                menu.style.display = 'block';
            }
        }
        
        function connectToNetwork() {
            const newUsername = document.getElementById('usernameInput').value.trim();
            if (newUsername && newUsername !== username) {
                if (galaxies[username]) {
                    galaxies[username].dispose();
                    delete galaxies[username];
                }
                
                username = newUsername;
                galaxies[username] = new Galaxy(username, avatarObject.position.clone());
                
                simulateOtherPlayers();
            }
            
            document.getElementById('connectButton').textContent = 'Conectado';
            document.getElementById('connectButton').disabled = true;
        }
        
        function simulateOtherPlayers() {
            for (const playerId in otherPlayers) {
                if (galaxies[playerId]) {
                    galaxies[playerId].dispose();
                    delete galaxies[playerId];
                }
            }
            
            otherPlayers = {};
            
            const playerCount = 2 + Math.floor(Math.random() * 3);
            const playerNames = ["Melodía", "Armonía", "Ritmo", "Sonata", "Sinfónico", "Crescendo"];
            
            for (let i = 0; i < playerCount; i++) {
                const playerId = playerNames[i];
                
                const distance = 50 + Math.random() * 250;
                const angle = Math.random() * Math.PI * 2;
                
                const position = new THREE.Vector3(
                    Math.cos(angle) * distance,
                    (Math.random() - 0.5) * 50,
                    Math.sin(angle) * distance
                );
                
                otherPlayers[playerId] = {
                    position: position,
                    lastUpdate: Date.now()
                };
                
                galaxies[playerId] = new Galaxy(playerId, position);
                
                simulatePlayerNotes(playerId);
            }
            
            updatePlayersList();
        }
        
        function simulatePlayerNotes(playerId) {
            if (!galaxies[playerId]) return;
            
            const note = 48 + Math.floor(Math.random() * 36);
            const velocity = 50 + Math.floor(Math.random() * 77);
            
            galaxies[playerId].addNote(note, velocity);
            
            const nextDelay = 200 + Math.random() * 1800;
            setTimeout(() => {
                simulatePlayerNotes(playerId);
            }, nextDelay);
        }
        
        function updatePlayersList() {
            const container = document.getElementById('playersOnline');
            container.innerHTML = '';
            
            const playerCount = Object.keys(otherPlayers).length + 1;
            container.innerHTML = `<p>Jugadores en línea: ${playerCount}</p>`;
            
            const localItem = document.createElement('div');
            localItem.className = 'midi-device-item active';
            localItem.textContent = `${username} (Tú)`;
            container.appendChild(localItem);
            
            for (const playerId in otherPlayers) {
                const playerItem = document.createElement('div');
                playerItem.className = 'midi-device-item';
                playerItem.textContent = playerId;
                container.appendChild(playerItem);
            }
        }

        function initMIDI() {
            if (navigator.requestMIDIAccess) {
                navigator.requestMIDIAccess({ sysex: false })
                    .then(onMIDISuccess, onMIDIFailure);
            } else {
                midiStatusElement.textContent = 'Tu navegador no soporta Web MIDI API';
            }
        }

        function onMIDISuccess(access) {
            midiAccess = access;
            midiStatusElement.textContent = 'MIDI conectado. Selecciona dispositivos en la configuración.';
            
            midiAccess.addEventListener('statechange', updateDeviceList);
            
            updateDeviceList();
        }

        function onMIDIFailure(error) {
            midiStatusElement.textContent = `Error al acceder a MIDI: ${error}`;
        }

        function updateDeviceList() {
            if (!midiAccess) return;
            
            const container = document.getElementById('midiDevicesContainer');
            container.innerHTML = '';
            
            let deviceCount = 0;
            
            midiAccess.inputs.forEach(input => {
                deviceCount++;
                
                const deviceItem = document.createElement('div');
                deviceItem.className = 'midi-device-item';
                deviceItem.dataset.id = input.id;
                
                const deviceName = document.createElement('span');
                deviceName.textContent = input.name || `Dispositivo ${deviceCount}`;
                deviceItem.appendChild(deviceName);
                
                const toggleBtn = document.createElement('div');
                toggleBtn.className = 'toggle-button';
                if (activeInputs.has(input.id)) {
                    toggleBtn.classList.add('active');
                    deviceItem.classList.add('active');
                }
                deviceItem.appendChild(toggleBtn);
                
                // Mejorado: Manejando separadamente el clic en el dispositivo
                deviceItem.addEventListener('click', function(e) {
                    e.stopPropagation(); // Evita que el clic cierre el menú
                    toggleMIDIInput(input.id);
                    toggleBtn.classList.toggle('active');
                    deviceItem.classList.toggle('active');
                });
                
                container.appendChild(deviceItem);
            });
            
            if (deviceCount === 0) {
                container.innerHTML = '<p>No se encontraron dispositivos MIDI</p>';
            }
            
            midiStatusElement.textContent = `${deviceCount} dispositivo(s) MIDI encontrado(s). ${activeInputs.size} activo(s).`;
        }
        
        function toggleMIDIInput(inputId) {
            const input = midiAccess.inputs.get(inputId);
            
            if (activeInputs.has(inputId)) {
                input.removeEventListener('midimessage', onMIDIMessage);
                activeInputs.delete(inputId);
                console.log(`Dispositivo MIDI desactivado: ${input.name}`);
            } else {
                input.addEventListener('midimessage', onMIDIMessage);
                activeInputs.add(inputId);
                console.log(`Dispositivo MIDI activado: ${input.name}`);
            }
            
            midiStatusElement.textContent = `${midiAccess.inputs.size} dispositivo(s) MIDI encontrado(s). ${activeInputs.size} activo(s).`;
        }

        function onMIDIMessage(event) {
            const command = event.data[0] >> 4;
            const channel = event.data[0] & 0xf;
            
            const note = event.data[1];
            
            const velocity = (event.data.length > 2) ? event.data[2] : 0;
            
            if (command === 9 && velocity > 0) {
                if (galaxies[username]) {
                    galaxies[username].addNote(note, velocity);
                }
                
                midiStatusElement.textContent = `Nota: ${note}, Velocidad: ${velocity}`;
            }
            else if ((command === 8 || (command === 9 && velocity === 0))) {
                if (galaxies[username]) {
                    galaxies[username].removeNote(note);
                }
            }
        }

        // Iniciar todo cuando el DOM esté cargado
        document.addEventListener('DOMContentLoaded', function() {
            init();
            initMIDI();
        });
    </script>
</body>
</html>